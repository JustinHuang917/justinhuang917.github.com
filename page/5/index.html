<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ShareCore</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ShareCore">
<meta property="og:url" content="http://sharecore.net/page/5/index.html">
<meta property="og:site_name" content="ShareCore">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShareCore">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="ShareCore" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ShareCore</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">J.H</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="http://weibo.com/justinhuang">微博</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://sharecore.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-值得借鉴的Google测试经验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/29/值得借鉴的Google测试经验/" class="article-date">
  <time datetime="2014-06-28T16:01:03.000Z" itemprop="datePublished">2014-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/29/值得借鉴的Google测试经验/">值得借鉴的Google测试经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>近来读了《Google软件测试之道》一书，以下是我从书里得来的两点经验：</p>
<p><strong>一.紧密结合开发过程与测试</strong></p>
<p>测试之难，保证产品开发质量之难，每个公司每个团队，都会碰到各自的的问题和困难。但最为常见的抱怨（尤其是在互联网行业）是：<strong>开发人员不重视测试，测试人员人手不足，开发迭代又快，测不过来</strong>。不少团队还喜欢争论开发测试比是1：1还是1：5或者5：1的问题,经常搬出微软这些传统软件巨头的开发测试比是多少多少来为自己辩护。其实，靠堆积人海战术的测试，是不适合在线型的快速的产品交付模式的。Google在这条路上就是另辟新径。</p>
<p>Google的“新径”说到底其实也很简单，就是将开发过程和测试混合在一起，密不可分，他们认为测试是开发过程中必不可少的部分，当开发过程和测试一起携手联姻时，即是质量达成之时。 </p>
<p>Google的测试主管Patrick说道：<br><strong><em>一个团队能编写出高质量的产品的唯一途径是全体人员共同对质量负责，包括产品经理，开发人员，测试人员等所有人。达到此目的最好方式是使测试人员有能力将测试变成代码库的一个实际功能，而测试功能的地位和应该与真是客户看到的任何其它功能同等重要。</em></strong></p>
<p>Google将工程师团队分成以下三种角色：</p>
<p><strong>1. 软件开发工程师(SWE，software engineer)</strong></p>
<p>SWE就是传统上的开发角色，他们的职责就是实现用户使用功能的代码。但是除此之外，<strong>SWE还需要编写测试代码，包括进行测试驱动的设计，单元测试，参与构建各种大小规模的测试等</strong>。简单来说，SWE所有时间都是花在了代码编写上，包括功能代码以及对这些功能代码进行测试用的测试代码。</p>
<p><strong>2. 软件测试开发工程师(SET,software engineer in test)</strong></p>
<p><strong>SET应该是Google能促进开发过程与测试紧密合起来的最关键角色</strong>。SET的工作重心在于提供可测试性和通用性测试的基础框架上。传统的测试由于这一角色的缺乏，导致产品的可测试性难以保证，最后沦为开发人员由于编写测试代码困难，不愿意去写测试代码，而测试人员由于模块化测试困难，导致不能尽早介入到开发流程中去，而只能在产品交互后做停留在表面的集成测试。</p>
<p>而SET这一角色的存在，很好的解决了这一个问题。SET会提供各种mock/fake框架，SWE在编写代码时，可以利用这些框架与外部依赖解耦，使得产品的单元测试和测试的自动执行变得相当容易。同时，集成测试也可以更早地进行，提高了测试人员的效率。</p>
<p><strong>3.测试工程师(TE,test engineer)</strong></p>
<p><strong>TE更多地代表的是用户利益，他们需要把用户放在第一位来思考</strong>。 TE需要组织整体的质量实践，分析和解释测试执行结果，驱动测试执行，构建端到端的自动化测试。他们早期会通过关注bug数，以<strong>确认开发人员在测试方面是做得到位</strong>。当bug数减少后，他们在以用户使用的场景，来进行<strong>探索性的测试</strong>。</p>
<p>以上三个角色的紧密配合，完成了开发过程与测试的“联姻”。而这个负责“牵红线的月老”，我想就是SET这个角色。SET是产品可测试性的保证。同时，可测试性不只是将开发过程和测试紧密结合的基础，同时还是检验代码质量和架构是否优良的最好工具。我一直信奉下面这个公式：<strong><em>可测试性=低耦合=优秀的代码=良好的架构</em></strong></p>
<p><strong>二.版本发布的“爬，走，跑”模式</strong></p>
<p>熟悉google产品的，应该经常能看到google许多发布的版本后面都带着beta的标签，如我现在是用的chrome版本就是“33.0.1750.29 beta”。许多产品在线运营了多年，beta的标签也没有去掉，这个标签是在警示用户，产品仍处于改良之中。对于最终用户，只有产品达到99.99%的可用性，才会将beta的标签去掉。</p>
<p>一般一个产品在发布给用户之前，一般要经历金丝雀版本，开发版本，测试版本，beta或正式发布版本。</p>
<p><strong>金丝雀版本</strong>:即每日构建版本，用来排除一些明显问题的版本。这是一个极不稳定的版本，可能随时崩溃。一般只有产品的工程师（开发或测试人员）才会安装使用金丝雀版本。</p>
<p><strong>开发版本</strong>：这个是开发人员日常使用的版本，一般是每周发布一个。该版本具有一定的功能并通过了一系列的测试。所有这个产品下的工程师都被要求去安装这个版本，并在日常工作中真正使用它。这其实体现“Eating your own dog food”的软件开发“黄金法则”。</p>
<p><strong>测试版本</strong>：这是一个通过了持续测试的版本,一般是一个月里最佳版本。一般可以被挑选为内部尝鲜，当做整个公司的“dog food”。如果该版本能持续表现良好，可作为beta测试的候选版本。</p>
<p><strong>beta或发布版本</strong>：这个版本由非常稳定的测试版本演变而来，并经历了内部使用和通过所有质量考核的一个版本，也是对外发布的第一个版本。</p>
<p>这种“爬，走，跑”的模式，能给产品提供一个测试验证的良好机会，并尽快得到使用过程中的反馈。</p>
<p>以上两点，就是《Google软件测试之道》一书能带来的两点经验，书的其它大部分内容是许多Google内部人士的访谈，我认为这部分都“太Google”了，价值不是太大，也是此书的问题所在。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/06/29/值得借鉴的Google测试经验/" data-id="cipdywfw0001wm7sp5d5ugrzc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/测试/">测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-过载保护算法浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/21/过载保护算法浅析/" class="article-date">
  <time datetime="2014-06-20T16:01:40.000Z" itemprop="datePublished">2014-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/21/过载保护算法浅析/">过载保护算法浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>何为<strong>过载保护</strong>？所谓“过载”，即需求超过了负载能力;而“保护”则是指当“过载”发生了，采取必要的措施保护自己不受“伤害”。在计算机领域，尤其是分布式系统领域，“过载保护”是一个重要的概念。一个不具备“过载保护”功能的系统，是非常危险和脆弱的，很可能由于瞬间的压力激增，引起“<strong>雪崩效应</strong>”，导致系统的各个部分都同时崩溃，停止服务。这就好像在没有保险丝的保护下，电压突然变高，导致所有的电器都会被损坏一样，“过载保护”功能是系统的“保险丝”。</p>
<p>去年开始，写了一个RPC服务框架，用以承接各个业务系统在其上进行各类业务服务接口的开发与部署，供远端调用。之于此类的框架，“过载保护”就是一个必须具备的功能特性，用以保护底层提供服务的业务系统不受“恶意”调用或突发性调用的破坏。而在整个实现整个功能的过程中，我发现实现“过载保护”算法是一个很有趣也比较有挑战的活。今天就稍微介绍一下这方面的算法吧。</p>
<p>可能跟大多数人一样，拿到这个算法需求很容易想到一个简单而又有点粗暴的算法：设置一个单位时间（如10s）内的最大访问量，并维护一个单位时间里的计数器，当访问请求到达时，先判断单位控制时间是否已经超时，如果已经超时，重置计数器为0;否则，将计数器加1,并判断计数器的值是否超过最大访问量设置，如超过，则拒绝访问。</p>
<p>具体的伪代码如下：（当然，具体的代码实现还有考虑并发的情况）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();</span><br><span class="line"><span class="keyword">int</span> reqCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxReqCount=<span class="number">10000</span>;<span class="comment">//时间周期内最大请求数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> effectiveDuration=<span class="number">10</span>;<span class="comment">//时间控制周期</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now=getNowTime();</span><br><span class="line">    <span class="keyword">if</span> (now &lt;timeStamp+effectiveDuration)&#123;<span class="comment">//在时间控制范围内</span></span><br><span class="line">        reqCount++;</span><br><span class="line">        <span class="keyword">return</span> reqCount&gt;maxReqCount;<span class="comment">//当前时间范围内超过最大请求控制数</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        timeStamp=now;<span class="comment">//超时后重置</span></span><br><span class="line">        reqCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该算法实现确实是实现了“单位时间里最大访问量控制”这一需求，但是，仔细研究下，发现它在两个单位时间的临界值上的处理是有缺陷的。如：设需要控制的最大请求数为1w, 在第一个单位时间的最后一秒里达到的请求数为1w,接下来第二个单位时间内的第一秒里达到请求数也是1w,由于超时重置发生在两个单位时间之间，所以这2w个请求都将通过控制，也就是说在2s里处理2w个请求，与我们设置的10s里1w个请求的需求相违背。</p>
<p>换句话说，这个算法，对请求的控制不够平滑。那是不是还有更平滑的算法呢？有，<strong>漏桶算法（Leaky Bucket）</strong>就是其一。</p>
<p><img src="/images/Leaky_bucket.JPG"></p>
<p>（图来自wikipedia）</p>
<p>如上图所示，我们假设系统是一个漏桶，当请求到达时，就是往漏桶里“加水”，而当请求被处理掉，就是水从漏桶的底部漏出。水漏出的速度是固定的，当“加水”太快，桶就会溢出，也就是“拒绝请求”。从而使得桶里的水的体积不可能超出桶的容量。</p>
<p>上面的分析可以看出，该算法存在三个变量：桶的容量capacity，水漏出的速度rate，以及当前的水量water。</p>
<p>算法伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();        </span><br><span class="line"><span class="keyword">int</span> capacity;        <span class="comment">// 桶的容量</span></span><br><span class="line"><span class="keyword">int</span> rate ;          <span class="comment">//水漏出的速度</span></span><br><span class="line"><span class="keyword">int</span> water;          <span class="comment">//当前水量</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先执行漏水，因为rate是固定的，所以可以认为“时间间隔*rate”即为漏出的水量</span></span><br><span class="line">  <span class="keyword">long</span>  now = getNowTime();</span><br><span class="line">  water = max(<span class="number">0</span>, water- (now - timeStamp)*rate);</span><br><span class="line">  timeStamp = now;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (water &lt; capacity) &#123; <span class="comment">// 水还未满，加水</span></span><br><span class="line">    water ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//水满，拒绝加水</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上算法，我们可以通过调整capacity的值，来控制系统处理的最大请求数。而上文我们提到的时间边界处理的不够平滑问题，也可以很好的解决了，因为在每次进桶前都将执行“漏水”的操作，时间的切片不再是一个固定的值。</p>
<p>如果你现在正在维基百科上查看“漏桶算法”的篇章，你会发现有一个与“漏桶算法”相关联的算法叫<strong>令牌桶(Tocken Bucket)</strong>算法。令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。</p>
<p>令牌桶算法伪代码如下，跟漏桶算法很相似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();        </span><br><span class="line"><span class="keyword">int</span> capacity;              <span class="comment">// 桶的容量</span></span><br><span class="line"><span class="keyword">int</span> rate ;              <span class="comment">//令牌放入速度</span></span><br><span class="line"><span class="keyword">int</span> tokens;            <span class="comment">//当前水量</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先执行添加令牌的操作</span></span><br><span class="line">  <span class="keyword">long</span>  now = getNowTime();</span><br><span class="line">  tokens = max(capacity, tokens+ (now - timeStamp)*rate);</span><br><span class="line">  timeStamp = now;</span><br><span class="line">  <span class="comment">//令牌已用完，拒绝访问</span></span><br><span class="line">  <span class="keyword">if</span>(tokens&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//还有令牌，领取令牌</span></span><br><span class="line">    tokens--;</span><br><span class="line">    retun <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是关于漏桶算法和令牌桶算法的基本介绍，你趋向于用哪个呢？我现在用的是“漏桶”，没有什么原因，因为我首先看到的它，然后才看到“令牌桶”。但当然，实现这两个算法后，离真正的过载保护还有许多工程上的问题需要解决，比如当系统是多个节点组成的集群来提供服务时，我们需要统一的存储（一般用Redis之类的内存级存储较为合适）来维护当前桶的状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/06/21/过载保护算法浅析/" data-id="cipdywfuu0008m7spxieysdji" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员持续学习之道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/15/程序员持续学习之道/" class="article-date">
  <time datetime="2014-06-14T16:02:25.000Z" itemprop="datePublished">2014-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/15/程序员持续学习之道/">程序员持续学习之道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我其实是一个悲观主义者，从开始成为一名程序员的那一天开始，我就对自己的职业充满着担忧。早期，我担忧的是我刚进入这一行，落后身边从事这一行多年的人太多，跟他们比，我一开始就处于“不公平“的起跑线上；二是当我稍微深入这行后，发现技术的道路充满了歧路和死胡同，稍不留神，就将落入再也跟不上技术进步的节奏，身边也充斥着类似的示例。</p>
<p>好在在这条路上，我找到了一个克服担忧的良方：学习，坚持不懈的学习！</p>
<p>人类最大的恐惧莫过于对未知的恐惧，而学习，是克服未知的一个最有效途径。那作为一个程序员，该如何才能做到坚持不懈的学习呢？我想主要有以下几点：</p>
<p> <strong>1. 不抗拒变化，跟踪变化</strong></p>
<p>这里说的变化，更多指的是技术的变化。新技术永远层出不穷，如果你抗拒变化，或惧怕变化，在心里优势上就落后了一大截。很多程序员的技术道路越走越窄，当一门新技术来临时，他们从不去了解或研究，他们要么认为这是”换汤不换药“的”技术幌子“，不值得去研究，要么等着别人去研究，自己被动的接受别人的结论与成果。诚然，等待别人的研究结果也可行，但是，当身边没有人去研究呢？当研究的人不愿意提供给你他的研究结果呢？当别人的结论和结果是错误的呢？</p>
<p>当然，业界的新技术层出不穷，要去跟踪每一项新技术的变化也是不可能的，我的建议是尽量掌握基础的技术，越是基础的技术越是恒定。如计算机的体系架构，TCP，HTTP，各类编程范式，OOP，MVC架构等，都是好多年来没有发生过变化的技术了。许多新技术也是建立在他们上面，当你了解了这些基础的技术，建立在他们之上的新技术也就能很快掌握了，并能迅速而准确地对这些新技术作出“价值判断”。</p>
<p>技术的变化，其实也并不全是指业界的新技术来临，更多指的是，超出自己当前技术能力外，<strong>主动研究和选择的“新技术” ，主动丢弃老的套路和技术，不固步自封</strong>。见过很多的程序员，他们写了很多年的代码了，技术能力还停留在数据库层写一个Sql(存储过程)+前端调用上。为什么如此呢？因为自开始写代码起，这样简单粗暴的方式就可以解决他们面对的问题了。所以，当碰到新的问题，他们就继续沿用着这种方式，而从不去看看业界是不是有更合适的方案来解决。长此以往，他们的技术能力也就不会有任何的变化，工作十年，只是将第一年所学的技术重复十年而已。</p>
<p> <strong>2. 书宜杂读，业宜精钻</strong></p>
<blockquote>
<p>建筑学家梁思成赴美留学，其父梁启超告诫说：你该挤出一部分时间学些常识性东西，特别是文学或人文科学，稍稍多用点工夫就能有大的收获。我深怕你因所学太专一，把多彩的生活弄得平平淡淡，生活过于单调，则生厌倦心理，厌倦一生即成苦恼之事……书宜杂读，业宜精钻。</p>
</blockquote>
<p>学习本身应该是一件很快乐的事情，但如果只是一味地沉浸于专业学习之中，难免会将本来快乐的事情弄成平淡和单调，更可怕的是，由此产生厌倦心理，放弃学习。</p>
<p>所以，可以尽量跟随自己的兴趣，去更广泛地读书。历史，文学，心理学，哲学等等各方面的书都可以尝试去读，它们不仅丰富你的知识，更能让你在阅读中受到感动、教育和启迪。<strong>书读的更多更广泛，知道的事也就多，思路更加开阔，解决问题的能力也就能高于常人，从而反过来帮助到你专业能力的提升。</strong></p>
<p> <strong>3. 投资团队，积极打造学习型团队</strong></p>
<p>现代社会，难免的一点就是个人必须置身于群体之中，程序员更是如此。从群体心理学的角度来看，在群体里，个人的才智被削弱，异质性被同质性所吞没。由此，<strong>如果一个团队不爱学习，那么，其中的成员也很难坚持学习</strong>（个性和意志力特别强的人除外）。</p>
<p>如果你爱学习，请想办法让你的团队也变得爱学习，这样，你对学习的坚持将变得更加容易。或许你认为建立学习氛围，是团队领导的事情，跟自己无关。领导当然可以来做也需要来做这样的事情，但要明白的一点，学习这事，如果变成从上向下，就难免“政治化”了，容易失去它本身的意义。而从下往上，更能建立轻松和谐的学习环境。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/06/15/程序员持续学习之道/" data-id="cipdywfv5000om7sphdco4cka" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/常识/">常识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复杂性/">复杂性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/常识/">常识</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/春秋/">春秋</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务化/">服务化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式匹配/">模式匹配</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/13/不平则鸣/">不平则鸣</a>
          </li>
        
          <li>
            <a href="/2016/06/13/人言无可畏/">人言无可畏</a>
          </li>
        
          <li>
            <a href="/2016/06/13/设计的思考/">设计的思考</a>
          </li>
        
          <li>
            <a href="/2016/06/13/解决问题的思路/">解决问题的思路</a>
          </li>
        
          <li>
            <a href="/2016/06/13/I-O模型基本介绍/">I/O模型基本介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 J.H<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="http://weibo.com/justinhuang" class="mobile-nav-link">微博</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>