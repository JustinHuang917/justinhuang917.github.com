<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ShareCore</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ShareCore">
<meta property="og:url" content="http://sharecore.net/page/3/index.html">
<meta property="og:site_name" content="ShareCore">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShareCore">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="ShareCore" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ShareCore</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">J.H</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://sharecore.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-可扩展架构设计的三个维度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/05/可扩展架构设计的三个维度/" class="article-date">
  <time datetime="2014-07-04T16:00:01.000Z" itemprop="datePublished">2014-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/05/可扩展架构设计的三个维度/">可扩展架构设计的三个维度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>业界对于可扩展的系统架构设计有一个朴素的理念,就是：</p>
<p><strong>通过加机器就可以解决容量和可用性问题</strong></p>
<p>这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而言，容量和性能问题当然是首当其冲的。但是随着时间的向前，系统规模的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时并未充分考虑到这些问题，导致系统的重构成为常态，从而影响业务交付能力，还浪费人力财力！</p>
<p>对此，《可扩展的艺术》一书提出了一个更加系统的可扩展模型——<strong>AKF可扩展立方</strong>（Scalability Cube）。这个立方体中沿着三个坐标轴设置分别为：X、Y、Z。</p>
<pre><code>X轴扩展 —— 关注水平的数据和服务克隆，也就是前文提到的“加机器解决问题”
Y轴扩展 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分 
Z轴扩展 —— 关注服务和数据的优先级划分，如分地域划分
</code></pre><p>整个扩展模型，用下图来表示，其中原点代表完全无扩展的状态。</p>
<p><img src="/images/akf.jpg" style="width:500px"></p>
<p><strong>一.X轴扩展</strong></p>
<p>X轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。我们以生产汽车的工厂来举例：假设一个车间能完整的生产一辆汽车，为了短时间内生产更多的汽车，我们可以建设更多的车间，任何新增车间除了工作的效率可能不同之外，都是一个新的复制品，也能提供与原来车间相同的工作，生产出完整的汽车。给复制品分配工作就是一个X轴扩展的一个完美示例，说明了X轴扩展的思路，即把工作无偏向的分配给复制品，每个复制品在不考虑生产效率的情况下，谁来做这项工作是无偏向的,<strong>各个复制品之间不共享任何内容</strong>。</p>
<p>而在工程技术上来讲，X轴扩展主要有以下两种技术方案：</p>
<p><strong>1.负载均衡</strong></p>
<p>故名思议，负载均衡就是将用户的访问请求通过负载均衡器，均衡分配到由各个“复制品”组成的集群中去。当某个复制品出现故障，也能轻易地将相应“工作”转移给其它的复制品来“代为完成”。这中间涉及到的工程技术点包括了反向代理，DNS轮询，哈希负载均衡算法（一致性哈希），动态节点负载均衡（如按CPU，I/O）等。它的难点在于要求集群中的“复制品”是不共享任何内容，也就是我们常说的<strong>无状态</strong>。</p>
<p><strong>2.数据复制</strong></p>
<p>数据复制是指在数据存储层进行绝对平等地数据迁移，用于解决存储层I/O瓶颈以及可用性上的问题。由于存在多个复制品存储，为了使得每个复制品提供无差异的数据服务，我们需要在复制品之间同步或异步地复制数据。数据复制的方式包括了主从同步（常见的读/写分离），双主同步等。因为数据存储天生就是有状态的，数据复制的难点在于<strong>一致性</strong>的保证上，为了一致性的保证，从而也衍生了很多复杂的技术，比如Paxos选举算法等。</p>
<p><strong>二.Y轴扩展</strong></p>
<p>Y轴扩展表示的是根据数据的类型或者交易执行的类型（或者两者都有）来划分工作职责。一般称为面向服务或面向资源的扩展。我们再以生产汽车的工厂来举例：如亨利.福特所做的一样，将汽车制造的工序按专业性分成不同车间和流水线，不再是一个车间负责完成100%的任务，制造一辆完整的汽车，而是让这每个车间都执行一些子任务，如安装发动机，喷漆，安装玻璃等等。这样的分工，益处是明显的，每个车间负责的<strong>任务更简单</strong>，从而能更专业更高效的完成生产。</p>
<p>与汽车工厂的分工类似，为了降低系统复杂度，Y轴扩展会将庞大的整体应用拆分为一组服务。每个服务实现一组相关的功能，如订单管理、客户管理等。在工程上常见的方案是<strong>服务化架构(SOA)</strong>。比如对于一个电子商务平台，我们可以拆分成不同的服务，组成下面这样的架构：</p>
<p><img src="/images/soa.jpg" style="width:500px"></p>
<p>但通过观察上图容易发现，当服务数量增多时，服务调用关系变得复杂。为系统添加一个新功能，要调用的服务数也变得不可控，由此引发了服务管理上的混乱。所以，一般情况下，需要采用服务注册的机制形成服务网关来进行服务治理。系统的架构将变成下图所示：</p>
<p><img src="/images/soa1.jpg" style="width:500px"></p>
<p>同时，为了提升单个服务的可用性和容量，<strong>对每一个服务进行X轴扩展划分</strong>。</p>
<p><img src="/images/soa2.jpg" style="width:500px"></p>
<p><strong>三.Z轴扩展</strong></p>
<p>Z轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但又是完整的。继续以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种Z轴扩展。</p>
<p>对于系统而言，Z轴扩展一般是为了满足差异性的需求或者是为了安全隔离而采取的扩展措施。比如为了提供VIP用户服务，可以将系统完整地复制一份出来，与普通用户所使用的系统完全隔离开来;再如，针对不同的地域用户，系统自动切换到对应地域的子系统，为用户提供服务，都可以认为是Z轴扩展。同时，在系统的灰度部署上，我们也通常使用Z轴扩展来完成。</p>
<p>工程领域常见的Z轴扩展有以下两种方案：</p>
<p><strong>1.单元化架构</strong></p>
<p>在分布式服务设计领域，一个单元（Cell）就是满足某个分区所有业务操作的自包含闭环。如上面我们说到的Y轴扩展的SOA架构，客户端对服务端节点的选择一般是随机的，但是，如果在此加上Z轴扩展，那服务节点的选择将不再是随机的了，而是每个单元自成一体。如下图：</p>
<p><img src="/images/cell.jpg" style="width:500px"></p>
<p><strong>2.数据分区</strong></p>
<p>为了性能数据安全上的考虑，我们将一个完整的数据集按一定的维度划分出不同的子集。<br>一个分区（Shard），就是是整体数据集的一个子集。比如用尾号来划分用户，那同样尾号的那部分用户就可以认为是一个分区。数据分区为一般包括以下几种数据划分的方式：</p>
<pre><code>数据类型（如：业务类型）
数据范围（如：时间段，用户ID）
数据热度（如：用户活跃度，商品热度）
按读写分（如：商品描述，商品库存）
</code></pre><p>当然，数据分区也是有代价的，它将增加数据运维的难度，关联搜索的复杂度增加等。</p>
<p><strong>总结:</strong></p>
<p>一个在可扩展性上设计良好的系统，会充分考虑三个维度上的可扩展性。X轴上扩展处理的是平台或系统执行的交易量或工作量增长，虽然X轴扩展能够很好处理交易量的增长，但当系统复杂度的大幅度增加，或用户数量增加以及差异化服务需求出现，X轴扩展就难以应付了，如是我们可以通过Y轴扩展来处理系统复杂度增长的问题以及Z轴扩展来处理差异性化需求的问题。而当采用的扩展坐标轴不止一条时，那么<strong>X轴扩展总是其它扩展方法的次级划分</strong>。同时，这三个维度扩展性，使得系统性能上改善有了更多的方向，对于系统性能优化，也是至关重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/07/05/可扩展架构设计的三个维度/" data-id="ci7djyqkz001pghrrhg4vey6c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-值得借鉴的Google测试经验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/29/值得借鉴的Google测试经验/" class="article-date">
  <time datetime="2014-06-28T16:01:03.000Z" itemprop="datePublished">2014-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/29/值得借鉴的Google测试经验/">值得借鉴的Google测试经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>近来读了《Google软件测试之道》一书，以下是我从书里得来的两点经验：</p>
<p><strong>一.紧密结合开发过程与测试</strong></p>
<p>测试之难，保证产品开发质量之难，每个公司每个团队，都会碰到各自的的问题和困难。但最为常见的抱怨（尤其是在互联网行业）是：<strong>开发人员不重视测试，测试人员人手不足，开发迭代又快，测不过来</strong>。不少团队还喜欢争论开发测试比是1：1还是1：5或者5：1的问题,经常搬出微软这些传统软件巨头的开发测试比是多少多少来为自己辩护。其实，靠堆积人海战术的测试，是不适合在线型的快速的产品交付模式的。Google在这条路上就是另辟新径。</p>
<p>Google的“新径”说到底其实也很简单，就是将开发过程和测试混合在一起，密不可分，他们认为测试是开发过程中必不可少的部分，当开发过程和测试一起携手联姻时，即是质量达成之时。 </p>
<p>Google的测试主管Patrick说道：<br><strong><em>一个团队能编写出高质量的产品的唯一途径是全体人员共同对质量负责，包括产品经理，开发人员，测试人员等所有人。达到此目的最好方式是使测试人员有能力将测试变成代码库的一个实际功能，而测试功能的地位和应该与真是客户看到的任何其它功能同等重要。</em></strong></p>
<p>Google将工程师团队分成以下三种角色：</p>
<p><strong>1. 软件开发工程师(SWE，software engineer)</strong></p>
<p>SWE就是传统上的开发角色，他们的职责就是实现用户使用功能的代码。但是除此之外，<strong>SWE还需要编写测试代码，包括进行测试驱动的设计，单元测试，参与构建各种大小规模的测试等</strong>。简单来说，SWE所有时间都是花在了代码编写上，包括功能代码以及对这些功能代码进行测试用的测试代码。</p>
<p><strong>2. 软件测试开发工程师(SET,software engineer in test)</strong></p>
<p><strong>SET应该是Google能促进开发过程与测试紧密合起来的最关键角色</strong>。SET的工作重心在于提供可测试性和通用性测试的基础框架上。传统的测试由于这一角色的缺乏，导致产品的可测试性难以保证，最后沦为开发人员由于编写测试代码困难，不愿意去写测试代码，而测试人员由于模块化测试困难，导致不能尽早介入到开发流程中去，而只能在产品交互后做停留在表面的集成测试。</p>
<p>而SET这一角色的存在，很好的解决了这一个问题。SET会提供各种mock/fake框架，SWE在编写代码时，可以利用这些框架与外部依赖解耦，使得产品的单元测试和测试的自动执行变得相当容易。同时，集成测试也可以更早地进行，提高了测试人员的效率。</p>
<p><strong>3.测试工程师(TE,test engineer)</strong></p>
<p><strong>TE更多地代表的是用户利益，他们需要把用户放在第一位来思考</strong>。 TE需要组织整体的质量实践，分析和解释测试执行结果，驱动测试执行，构建端到端的自动化测试。他们早期会通过关注bug数，以<strong>确认开发人员在测试方面是做得到位</strong>。当bug数减少后，他们在以用户使用的场景，来进行<strong>探索性的测试</strong>。</p>
<p>以上三个角色的紧密配合，完成了开发过程与测试的“联姻”。而这个负责“牵红线的月老”，我想就是SET这个角色。SET是产品可测试性的保证。同时，可测试性不只是将开发过程和测试紧密结合的基础，同时还是检验代码质量和架构是否优良的最好工具。我一直信奉下面这个公式：<strong><em>可测试性=低耦合=优秀的代码=良好的架构</em></strong></p>
<p><strong>二.版本发布的“爬，走，跑”模式</strong></p>
<p>熟悉google产品的，应该经常能看到google许多发布的版本后面都带着beta的标签，如我现在是用的chrome版本就是“33.0.1750.29 beta”。许多产品在线运营了多年，beta的标签也没有去掉，这个标签是在警示用户，产品仍处于改良之中。对于最终用户，只有产品达到99.99%的可用性，才会将beta的标签去掉。</p>
<p>一般一个产品在发布给用户之前，一般要经历金丝雀版本，开发版本，测试版本，beta或正式发布版本。</p>
<p><strong>金丝雀版本</strong>:即每日构建版本，用来排除一些明显问题的版本。这是一个极不稳定的版本，可能随时崩溃。一般只有产品的工程师（开发或测试人员）才会安装使用金丝雀版本。</p>
<p><strong>开发版本</strong>：这个是开发人员日常使用的版本，一般是每周发布一个。该版本具有一定的功能并通过了一系列的测试。所有这个产品下的工程师都被要求去安装这个版本，并在日常工作中真正使用它。这其实体现“Eating your own dog food”的软件开发“黄金法则”。</p>
<p><strong>测试版本</strong>：这是一个通过了持续测试的版本,一般是一个月里最佳版本。一般可以被挑选为内部尝鲜，当做整个公司的“dog food”。如果该版本能持续表现良好，可作为beta测试的候选版本。</p>
<p><strong>beta或发布版本</strong>：这个版本由非常稳定的测试版本演变而来，并经历了内部使用和通过所有质量考核的一个版本，也是对外发布的第一个版本。</p>
<p>这种“爬，走，跑”的模式，能给产品提供一个测试验证的良好机会，并尽快得到使用过程中的反馈。</p>
<p>以上两点，就是《Google软件测试之道》一书能带来的两点经验，书的其它大部分内容是许多Google内部人士的访谈，我认为这部分都“太Google”了，价值不是太大，也是此书的问题所在。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/06/29/值得借鉴的Google测试经验/" data-id="ci7djyql2001sghrr1w8jyg7p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/测试/">测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-过载保护算法浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/21/过载保护算法浅析/" class="article-date">
  <time datetime="2014-06-20T16:01:40.000Z" itemprop="datePublished">2014-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/21/过载保护算法浅析/">过载保护算法浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>何为<strong>过载保护</strong>？所谓“过载”，即需求超过了负载能力;而“保护”则是指当“过载”发生了，采取必要的措施保护自己不受“伤害”。在计算机领域，尤其是分布式系统领域，“过载保护”是一个重要的概念。一个不具备“过载保护”功能的系统，是非常危险和脆弱的，很可能由于瞬间的压力激增，引起“<strong>雪崩效应</strong>”，导致系统的各个部分都同时崩溃，停止服务。这就好像在没有保险丝的保护下，电压突然变高，导致所有的电器都会被损坏一样，“过载保护”功能是系统的“保险丝”。</p>
<p>去年开始，写了一个RPC服务框架，用以承接各个业务系统在其上进行各类业务服务接口的开发与部署，供远端调用。之于此类的框架，“过载保护”就是一个必须具备的功能特性，用以保护底层提供服务的业务系统不受“恶意”调用或突发性调用的破坏。而在整个实现整个功能的过程中，我发现实现“过载保护”算法是一个很有趣也比较有挑战的活。今天就稍微介绍一下这方面的算法吧。</p>
<p>可能跟大多数人一样，拿到这个算法需求很容易想到一个简单而又有点粗暴的算法：设置一个单位时间（如10s）内的最大访问量，并维护一个单位时间里的计数器，当访问请求到达时，先判断单位控制时间是否已经超时，如果已经超时，重置计数器为0;否则，将计数器加1,并判断计数器的值是否超过最大访问量设置，如超过，则拒绝访问。</p>
<p>具体的伪代码如下：（当然，具体的代码实现还有考虑并发的情况）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();</span><br><span class="line"><span class="keyword">int</span> reqCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxReqCount=<span class="number">10000</span>;<span class="comment">//时间周期内最大请求数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> effectiveDuration=<span class="number">10</span>;<span class="comment">//时间控制周期</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now=getNowTime();</span><br><span class="line">    <span class="keyword">if</span> (now &lt;timeStamp+effectiveDuration)&#123;<span class="comment">//在时间控制范围内</span></span><br><span class="line">        reqCount++;</span><br><span class="line">        <span class="keyword">return</span> reqCount&gt;maxReqCount;<span class="comment">//当前时间范围内超过最大请求控制数</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        timeStamp=now;<span class="comment">//超时后重置</span></span><br><span class="line">        reqCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该算法实现确实是实现了“单位时间里最大访问量控制”这一需求，但是，仔细研究下，发现它在两个单位时间的临界值上的处理是有缺陷的。如：设需要控制的最大请求数为1w, 在第一个单位时间的最后一秒里达到的请求数为1w,接下来第二个单位时间内的第一秒里达到请求数也是1w,由于超时重置发生在两个单位时间之间，所以这2w个请求都将通过控制，也就是说在2s里处理2w个请求，与我们设置的10s里1w个请求的需求相违背。</p>
<p>换句话说，这个算法，对请求的控制不够平滑。那是不是还有更平滑的算法呢？有，<strong>漏桶算法（Leaky Bucket）</strong>就是其一。</p>
<p><img src="/images/Leaky_bucket.JPG"></p>
<p>（图来自wikipedia）</p>
<p>如上图所示，我们假设系统是一个漏桶，当请求到达时，就是往漏桶里“加水”，而当请求被处理掉，就是水从漏桶的底部漏出。水漏出的速度是固定的，当“加水”太快，桶就会溢出，也就是“拒绝请求”。从而使得桶里的水的体积不可能超出桶的容量。</p>
<p>上面的分析可以看出，该算法存在三个变量：桶的容量capacity，水漏出的速度rate，以及当前的水量water。</p>
<p>算法伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();        </span><br><span class="line"><span class="keyword">int</span> capacity;        <span class="comment">// 桶的容量</span></span><br><span class="line"><span class="keyword">int</span> rate ;          <span class="comment">//水漏出的速度</span></span><br><span class="line"><span class="keyword">int</span> water;          <span class="comment">//当前水量</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先执行漏水，因为rate是固定的，所以可以认为“时间间隔*rate”即为漏出的水量</span></span><br><span class="line">  <span class="keyword">long</span>  now = getNowTime();</span><br><span class="line">  water = max(<span class="number">0</span>, water- (now - timeStamp)*rate);</span><br><span class="line">  timeStamp = now;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (water &lt; capacity) &#123; <span class="comment">// 水还未满，加水</span></span><br><span class="line">    water ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//水满，拒绝加水</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上算法，我们可以通过调整capacity的值，来控制系统处理的最大请求数。而上文我们提到的时间边界处理的不够平滑问题，也可以很好的解决了，因为在每次进桶前都将执行“漏水”的操作，时间的切片不再是一个固定的值。</p>
<p>如果你现在正在维基百科上查看“漏桶算法”的篇章，你会发现有一个与“漏桶算法”相关联的算法叫<strong>令牌桶(Tocken Bucket)</strong>算法。令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。</p>
<p>令牌桶算法伪代码如下，跟漏桶算法很相似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timeStamp=getNowTime();        </span><br><span class="line"><span class="keyword">int</span> capacity;              <span class="comment">// 桶的容量</span></span><br><span class="line"><span class="keyword">int</span> rate ;              <span class="comment">//令牌放入速度</span></span><br><span class="line"><span class="keyword">int</span> tokens;            <span class="comment">//当前水量</span></span><br><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先执行添加令牌的操作</span></span><br><span class="line">  <span class="keyword">long</span>  now = getNowTime();</span><br><span class="line">  tokens = max(capacity, tokens+ (now - timeStamp)*rate);</span><br><span class="line">  timeStamp = now;</span><br><span class="line">  <span class="comment">//令牌已用完，拒绝访问</span></span><br><span class="line">  <span class="keyword">if</span>(tokens&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//还有令牌，领取令牌</span></span><br><span class="line">    tokens--;</span><br><span class="line">    retun <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是关于漏桶算法和令牌桶算法的基本介绍，你趋向于用哪个呢？我现在用的是“漏桶”，没有什么原因，因为我首先看到的它，然后才看到“令牌桶”。但当然，实现这两个算法后，离真正的过载保护还有许多工程上的问题需要解决，比如当系统是多个节点组成的集群来提供服务时，我们需要统一的存储（一般用Redis之类的内存级存储较为合适）来维护当前桶的状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/06/21/过载保护算法浅析/" data-id="ci7djyqk50008ghrre3u796nk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复杂性/">复杂性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/常识/">常识</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/春秋/">春秋</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务化/">服务化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式匹配/">模式匹配</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/08/24/模式匹配初析/">模式匹配初析</a>
          </li>
        
          <li>
            <a href="/2014/08/10/字符编码常识及问题解析/">字符编码常识及问题解析</a>
          </li>
        
          <li>
            <a href="/2014/08/02/浅谈服务化架构/">浅谈服务化架构</a>
          </li>
        
          <li>
            <a href="/2014/07/27/面对喷子明哲保身/">面对喷子明哲保身</a>
          </li>
        
          <li>
            <a href="/2014/07/20/技术的进化/">技术的进化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 J.H<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>