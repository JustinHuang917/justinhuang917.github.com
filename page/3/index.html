<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ShareCore</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ShareCore">
<meta property="og:url" content="http://sharecore.net/page/3/index.html">
<meta property="og:site_name" content="ShareCore">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShareCore">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="ShareCore" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ShareCore</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">J.H</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="http://weibo.com/justinhuang">微博</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://sharecore.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-字符编码常识及问题解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/10/字符编码常识及问题解析/" class="article-date">
  <time datetime="2014-08-10T15:53:04.000Z" itemprop="datePublished">2014-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/10/字符编码常识及问题解析/">字符编码常识及问题解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>在面试的笔试题里出了一道开放性的题：请简述<span class="keyword">Unicode</span>与UTF-<span class="number">8</span>之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几
，确实挺失望的。所以今天就结合我以前做过的一个关于字符编码的分享，总结一些与字符编码相关的知识和问题。如果你这方面的
知识已经掌握的足够了，可以忽略这篇文字。但如果你没法很好的回答我上面的面试题，或经常被乱码的问题所困扰，还是不妨一读。
</code></pre><h2 id="基本常识">基本常识</h2><h3 id="1-位和字节">1.位和字节</h3><p>说起编码，我们必须从最基础的说起，<strong>位和字节</strong>(别觉得这个过于简单不值一说，我还真见过很多个不能区分这两者的程序员)。位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256（ 2^8 ）个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。</p>
<p>而我们通常所讲的字符编码，就是指<strong>定义一套规则</strong>，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：</p>
<pre><code><span class="number">01000001</span>（<span class="number">0x41</span>）&lt;-&gt; <span class="number">65</span> &lt;-&gt; <span class="string">'A'</span>
</code></pre><p>即用字位序“01000001”来表示字母’A’。</p>
<h3 id="2-拉丁字符">2.拉丁字符</h3><p>拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是<strong>基础拉丁字母</strong>,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为<strong>基础拉丁字符</strong>，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如’Á’)，形成了<strong>派生拉丁字母</strong>，其表示的字符范围在各种语言有所不同，而<strong>完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集</strong>。是比基础拉丁字符集大很多的一个集合。</p>
<h2 id="编码标准">编码标准</h2><p>前文提到，字符编码是一套规则。既然是规则，就必须有标准。下面我就仔细说说常见的字符编码标准。</p>
<h3 id="1-拉丁编码">1.拉丁编码</h3><p>ASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的<strong>ASCII编码也只支持基础拉丁字符</strong>。ASCII的设计也很简单，<strong>用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’</strong>。即表示字符含义的位数为7位，不难算出其可表达字符数为2^7 =128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应：</p>
<table><br><tr><th>字符类型</th><th>    字符</th><th>二进制  </th><th>    16进制</th><th>10进制</th></tr><br><tr><td>可打印字符</td><td>A</td><td>    01000001</td><td>    0x41</td><td>65</td></tr><br><tr><td>可打印字符</td><td>a</td><td>    01100001</td><td>    0x61</td><td>97</td></tr><br><tr><td>控制字符</td><td>    \r</td><td>00001101</td><td>    0x0D</td><td>13</td></tr><br><tr><td>控制字符</td><td>    \n</td><td>00001010</td><td>    0xA</td><td>10</td></tr><br></table>

<p>前面说到了，ASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？</p>
<p>当然，最简单的办法就是将美国人没有用到的<strong>第8位也用上</strong>就好了，这样能表达的字符个数就达到了2^8 =256个，相比较原来，增长了一倍， 这个编码规则也常被称为<strong>EASCII</strong>。EASCII基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了<strong>ISO 8859</strong>,为解决256个字符不够用的问题，<strong>ISO 8859采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成</strong>，分别称为ISO 8859-n(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如ISO 8859-1对应西欧语言，ISO 8859-2对应中欧语言等。其中大家所熟悉的<strong>Latin-1就是ISO 8859-1的别名,它表示整个西欧的字符集范围</strong>。<br><strong>需要注意的一点的是，ISO 8859-n与ASCII是兼容的，即其0000000(0x00)-01111111(0x7f)范围段与ASCII保持一致，而10000000（0x80）-11111111(0xFF)范围段被扩展用到不同的字符集。</strong></p>
<h3 id="2-中文编码">2.中文编码</h3><p>以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文GB2312（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，GB2312还是是用一个字节来表示以兼容ASCII）。我们用下表来说明各中文编码之间的规则和兼容性。</p>
<p><img src="/images/codes/cn_codes.jpg" style="width:500px"></p>
<p>对于中文编码，其规则实现上是很简单的，一般都是简单的<strong>字符查表</strong>即可，重要的是要注意其相互之间的<strong>兼容性</strong>问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。</p>
<h3 id="3-Unicode">3.Unicode</h3><p>以上可以看到，针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，Unicode就是一种。为了能独立表示世界上所有的字符，Unicode采用<strong>4个字节表示一个字符</strong>,这样理论上Unicode能表示的字符数就达到了2^31 = 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：</p>
<pre><code>微 &lt;<span class="function">-&gt;</span>  <span class="string">\u5fae</span>   &lt;<span class="function">-&gt;</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01011111</span> <span class="number">10101110</span>
信 &lt;<span class="function">-&gt;</span>    <span class="string">\u4fe1</span>     &lt;<span class="function">-&gt;</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01001111</span> <span class="number">11100001</span>
</code></pre><p>容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0,这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？</p>
<p>以上两个问题，困扰着Unicode，让Unicode的推广上一直面临着困难。直至UTF-8作为Unicode的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，<strong>UTF-8是Unicode的一种实现方式，而Unicode是一个统一标准规范，Unicode的实现方式除了UTF-8还有其它的，比如UTF-16等。</strong></p>
<p>话说当初大牛Ben Thomson吃饭时，在一张餐巾纸上，设计出了UTF-8，然后回到房间，实现了第一版的UTF-8。关于UTF-8的基本规则，其实简单来说就两条（来自阮一峰老师的总结）：</p>
<pre><code>规则1：对于单字节字符，字节的第一位为0，后7位为这个符号的Unicode码，所以对于拉丁字母，UTF-8与ASCII码是一致的。

规则2：对于<span class="keyword">n</span>字节(<span class="keyword">n</span>&gt;1)的字符，第一个字节前<span class="keyword">n</span>位都设为1，第<span class="keyword">n</span>+1位为0，后面字节的前两位一律设为10，
剩下没有提及的位，全部为这个符号的Unicode编码。
</code></pre><p>通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表，</p>
<p><img src="/images/codes/utf8.jpg" style="width:500px"></p>
<p>举例来说，’微’的Unicode是’\u5fae’，二进制表示是”00000000 00000000 01011111 10101110“，其取值就位于’0000 0800-0000 FFFF’之间，所以其UTF-8编码为’<strong>111</strong>00101 <strong>10</strong>111110 <strong>10</strong>101110’ （加粗部分为固定编码内容）。</p>
<p>通过以上简单规则，UTF-8采取变字节的方式，解决了我们前文提到的关于Unicode的两大问题。同时，作为中文使用者需要注意的一点是<strong>Unicode(UTF-8)与GBK，GB2312这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换,如需转换，一般通过GBK查表的方式来进行</strong>。</p>
<h2 id="常见问题及解答">常见问题及解答</h2><h3 id="1-windows_Notepad中的编码ANSI保存选项，代表什么含义？">1.windows Notepad中的编码ANSI保存选项，代表什么含义？</h3><p>ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，<strong>如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码</strong>。</p>
<h3 id="2-什么是UTF-8的BOM？">2.什么是UTF-8的BOM？</h3><p>BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的<a href="http://sharecore.info/blog/2013/04/05/parse-csv-to-sql-for-insert/" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="3-为什么数据库Latin1字符集（单字节）可以存储中文呢？">3.为什么数据库Latin1字符集（单字节）可以存储中文呢？</h3><p>其实不管需要使用几个字节来表示一个字符，但最小的存储单位都是字节,所以，<strong>只要能保证传输和存储的字节顺序不会乱即可</strong>。作为数据库，只是作为存储的使用的话，只要能保证存储的顺序与写入的顺序一致，然后再按相同的字节顺序读出即可，翻译成语义字符的任务交给应用程序。比如’微’的UTF-8编码是’0xE5 0xBE 0xAE’，那数据库也存储’0xE5 0xBE 0xAE’三个字节，其它应用按顺序从数据库读取，再按UTF-8编码进行展现。这当然是一个看似完美的方案，但是只要写入，存储，读取过程中岔出任何别的编码，都可能导致乱码。</p>
<h3 id="4-Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？">4.Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？</h3><p><img src="/images/codes/mysql_var.jpg" style="width:500px"></p>
<p>我们分别解释：</p>
<p><strong>character_set_client</strong>：客户端来源的数据使用的字符集，用于客户端显式告诉客户端所发送的语句中的的字符编码。</p>
<p><strong>character_set_connection</strong>：连接层的字符编码，mysql一般用character_set_connection将客户端的字符转换为连接层表示的字符。</p>
<p><strong>character_set_results</strong>:查询结果从数据库读出后，将转换为character_set_results返回给前端。</p>
<p>而我们常见的解决乱码问题的操作：</p>
<pre><code><span class="function"><span class="title">mysql_query</span><span class="params">(<span class="string">'SET NAMES GBK'</span>)</span></span>
</code></pre><p>其相当于将以上三个字符集统一全部设置为GBK，这三者一致时，一般就解决了乱码问题。</p>
<p>character_set_database:当前选中数据库的默认字符集，如当create table时没有指定字符集，将默认选择该字符集。</p>
<p>character_set_database已经character_set_system，一般用于数据库系统内部的一些字符编码，处理数据乱码问题时，我们基本可以忽略。</p>
<h3 id="5-什么情况下，表示信息丢失？">5.什么情况下，表示信息丢失？</h3><p>对于mysql数据库，我们可以通过<strong>hex(colname)</strong>函数（其它数据库也有类似的函数，一些文本文件编辑器也具有这个功能），查看实际存储的字节内容，如：</p>
<p><img src="/images/codes/mysql_hex.jpg" style="width:500px"></p>
<p>通过查看存储的字节序，我们可以从根本上了解存储的内容是什么编码了。而当发现<strong>存储的内容全部是’3F’时，就表明存储的内容由于编码问题，信息已经丢失了，无法再找回</strong>。</p>
<p>之所以出现这种信息丢失的情况，一般是将不能相互转换的字符集之间做了转换，比如我们在前文说到，UTF-8只能一个个字节地变成Latin-1，但是根本不能转换的，因为两者之间没有转换规则，Unicode的字符对应范围也根本不在Latin-1范围内，所以只能用’?(0x3F)’代替了。</p>
<h2 id="总结：">总结：</h2><p>本文从基础知识与实际中碰到的问题上，解析了字符编码相关内容。而之所以要从头介绍字符编码的基础知识，是为了更好的从原理上了解与解决日常碰到的编码问题，只有从根本上了解了不同字符集的规则及其之间的关系与兼容性，才能更好的解决碰到的乱码问题，也能避免由于程序中不正确的编码转换导致的信息丢失问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/08/10/字符编码常识及问题解析/" data-id="cipdywfvt001lm7spb1a6jw6c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术常识/">技术常识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈服务化架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/02/浅谈服务化架构/" class="article-date">
  <time datetime="2014-08-02T15:54:42.000Z" itemprop="datePublished">2014-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/02/浅谈服务化架构/">浅谈服务化架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>这两年来，在服务化架构设计上的实践比较多，在此对关于服务化设计一些经验稍作总结，
知识经验水平有限，如有欠缺和不准确的地方，还请指出修正！     
</code></pre><p>我在<a href="http://sharecore.net/2014/07/05/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6/" target="_blank" rel="external">《可扩展架构设计的三个维度》</a>一文里，谈到服务化架构（SOA）在保证系统扩展性上，是一个比较好的架构设计实践。也谈到了通过服务网关的形式来进行多服务的注册与管理等。但困于篇幅，并未展开讲关于服务化架构实现层面上的具体细节。本文就结合我这两年来，在服务化架构设计上的一些实践经验，谈谈一个服务化框架其应该具备的一些功能以及其基本实现方式。</p>
<p>这里说到的“服务”，本质上来说，就是指“RPC”。单纯的RPC功能实现，其实很简单，无非就是client发起调用，中间某个组件（甚至就是client本身）拦截调用信息，序列化后将信息传输到server端，server端收到调用请求后反序列化，根据请求详细发起实际调用后返回响应传输回给client端。这样的RPC很常见，比如常见的存储过程调用就是一例。但是在一个复杂的业务环境，如何管理和协同这些大量的RPC才是最麻烦的事情。所以，在此谈的“服务化”更多指的是对RPC的管理。</p>
<p>一个复杂业务环境下的大量RPC究竟会遇到哪些问题呢？换句话说，一个服务化管理框架究竟应该具备哪些功能特性才算基本完备呢？以下是我的一些看法</p>
<p><strong>1.协议选型</strong></p>
<p><strong>数据序列化</strong></p>
<p>为整个环境里的服务采用统一的数据序列化协议，其益处是显而易见的，能大大降低服务提供者和服务调用者之间的沟通成本，同时也可以为服务提供者减少应对不同数据协议需求而带来的代码复杂性。所以，在开始设计一个服务化框架时，第一件重要的事情就是选定一个标准的数据序列化协议。如何选择合适的序列化协议重点需要从<strong>扩展性，传输性能以及业界通用性（换句话说就是不同技术/语言的支持程度）</strong>三个因素里来协调选择。当前看来，在这三个方面都做的比较好，也是使用最广泛的就是<strong>Json</strong>和<strong>Protobuf</strong>了，基于文本的Json在可读性和灵活性上占优，而基于二进制的Protobuf在传输性能生更胜一筹。而如果整个环境开发的技术栈比较统一，比如全是Java/.NET，也可以选择对这一技术更加友好的序列化协议。我这一次选择的就是Json，因为从面对的业务情况来看，传输性能不是根本矛盾，而灵活性要求较高，同时服务使用者使用的技术也较为多样化。</p>
<p>在序列化协议的选定上<strong>要避免的一个误区就是采用自定义协议而不是业界通用协议</strong>,自定义协议将很容易面临扩展性和使用推广方面的问题，同时，当有新的开发人员加入进来，其需要花费时间来学习与了解。</p>
<p><strong>通讯协议选择</strong></p>
<p>通讯协议上的选择上灵活性比较大，有多种选择，可以在基于HTTP或TCP链接上建立自己的通讯协议。比如可以设计一个简单的header（定长）+body（序列化的请求/响应）。如果采取json作序列化协议的情况下，可以跟我本次的选择一样，采取一个类似<a href="http://en.wikipedia.org/wiki/JSON-RPC" target="_blank" rel="external">json-rpc</a>, 完全基于json的通讯协议：</p>
<p>Resust:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"<span class="attribute">ActionName</span>":<span class="value"><span class="string">"Do"</span></span>,</span><br><span class="line">	"<span class="attribute">AppId</span>":<span class="value"><span class="string">"xxxxxx"</span></span>,</span><br><span class="line">	"<span class="attribute">RequestContent</span>":<span class="value">&#123;&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Response:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“RequestId”:“xxxxxxxxx”，</span><br><span class="line">	“HasError”:false,</span><br><span class="line">	"ResponseContent":&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于服务访问对象主要为企业内部的情况，不太建议采取与http完全绑定的restful协议，这将牺牲链接层选择的灵活性。</p>
<p><strong>2.注册与授权管理</strong></p>
<p>注册管理是解决系统交互复杂性的必备良药，我建议超过三个系统之间的系统交互，都应该具备注册管理功能。对于服务化架构来说，注册管理也是最为核心的一项功能。当服务数量和服务使用者数量爆发性增长时，最难回答的问题就是“服务被谁使用了？”以及“有哪些服务可供使用？”，注册管理就是解决这两个问题的最佳方式与实践。 </p>
<p>注册管理的实现上其实也很简单，提供一个Config Server（配置中心），收集服务提供者的注册信息（包括服务名称，服务地址（可以多个），版本，超时时间控制等），我们称为<strong>服务的元信息</strong>。而当服务使用者需要调用相应的服务时，就可以利用这些元信息来查找和调用相应的服务了。</p>
<p>不过，在元信息的使用上，存在两者架构方式</p>
<p>1.服务使用者访问统一的服务中转器，由服务中转器按照注册信息以及负载情况将请求转发到相应的服务地址上。服务执行后，响应信息返回到服务中心，服务中心将响应回送给调用方。</p>
<p><img src="/images/soa/service_2.png" alt="service_2"></p>
<p>这种方式的优点是能比较好的控制所有请求的调度。当服务元信息发生变化时，能及时地调整请求转发（负载）与超时控制等。缺点是请求和响应均需要由中转中心负责转发，性能耗费较大。同时，中转中心的可用性也容易产生问题，必须通过集群的方式来解决。</p>
<p>2.服务使用者负责从配置中心获取服务地址等信息，然后有由服务使用者直接向相对应地址上的服务发送请求，请求也直接由服务提供者返回给服务调用者。同时，服务使用者本身可以缓存一定的服务元信息，防止每次访问都要从配置中心获取，以降低配置中心的负载，增强整个系统的可用性。当配置中心的服务元信息发生变化时，通过通知的方式告知服务使用者更新本地缓存。</p>
<p><img src="/images/soa/service_1.png" alt="service_1"></p>
<p>这种架构方式与第一种架构相比，能显著降低性能的损耗，以及服务使用者对中心节点的直接依赖。但代价是需要彻底改造服务使用者的调用方式，框架的代码必须侵入到客户端的开发中去。一般会针对不同的客户端提供clientLib，但当客户端实现方式多样化时，这种代价是非常大的。</p>
<p>由于我这次面对的客户端多样性，客户端开发也不在控制范围内，所以选择就是第一种方式。</p>
<p>关于授权，可以与注册管理相互结合，将授权信息同一保存到配置中心。对于企业内部访问的服务，做到通过IP+AppId授权应该就够了。这里有个经验是可以将授权和服务版本确认两者结合起来，即在<strong>授权的同时完成服务版本的确定</strong>，而不采取由客户端发起访问时指定版本的方式，这样做的好处是框架和服务提供者对于服务版本变更和灰度发布具有更高的可控制性。</p>
<p><strong>3.路由与过载保护</strong></p>
<p>在<a href="http://sharecore.net/blog/2014/07/05/ke-kuo-zhan-jia-gou-de-san-ge-wei-du/" target="_blank" rel="external">《可扩展架构设计的三个维度》</a>一文里谈到通过单元化架构以满足Z轴扩展，以满足差异性的需求或者做到安全隔离。而<strong>服务路由是实现这种单元化架构的基本保障</strong>，以保证能将来自不同访问者请求或者不同的请求内容，分发到不同的服务提供区域去，形成单元化架构的闭环。当然，路由功能并不一定需要框架来独立实现，业界许多通用的（软）负载均衡器可以协助实现，如Nginx/HAProxy/LVS这些。但是这类通用的负载均衡软件的问题是路由算法比较通用，当需要扩展到与业务逻辑相关的路由绑定时，比较麻烦，比如需要用户ID按权重分配路由。在此建议，<strong>可以采取通用的负载均衡软件当第一层接入，而在服务节点之间采取自己实现路由模块的方式。</strong>而在实现路由模块时，需要将扩展性上的考虑放在第一位。 </p>
<p>对于服务化架构，保障提供服务提供者的业务系统不受“恶意”调用或突发性激增调用的破坏，过载保护功能至关重要，它能起到系统“保险丝”的效果。前文提到可用于接入的Nginx/HAProxy/LVS这些软件，也多少提供了过载保护的功能。如果自己实现过载保护模块，具体可参见我的<a href="http://sharecore.net/blog/2014/06/21/guo-zai-bao-hu-suan-fa-qian-xi/" target="_blank" rel="external">《过载保护算法浅析》</a>一文。对于过载保护的一个经验是：<strong>过载保护越靠近服务访问前端越好。</strong></p>
<p><strong>4.服务拆分与组合化</strong></p>
<p>传统的SOA概念，指的是不同的应用系统之间相互通过大粒度服务的方式进行集成。而当今的服务化架构已经摆脱了这一概念的束缚，更多讲的是系统内部模块级甚至是功能级的服务化模式。也就是说服务实现的粒度更小了。这当然为应用和服务的实现带来了更强的灵活性，服务交付周期也大大缩短了。但这样的细粒度拆分服务，带来的问题是项功能的实现需要访问的服务数量成倍的增加。如下图所示：一个客户下订单的功能实现需要分别访问：客户信息服务，产品类别服务，库存服务，订单管理服务等。</p>
<p><img src="/images/soa/service_3.png" alt="service_3"></p>
<p>这将显著增加功能实现的复杂性。为了解决这一问题，我们只能再次使用那条永远有效的“中间层定律”：<strong>任何计算机问题都可以通过中间加一层来解决。</strong> 我们可以将相应的服务组合成一个新的服务提供出去，比如上面的例子，我们可以按以下方式组合：</p>
<p><img src="/images/soa/service_4.png" alt="service_4"></p>
<p><strong>5.基于配置的服务运行时提供</strong></p>
<p>前文已经概述了一个服务化框架应该具有的一些基本功能以及一些基本的架构实现方式。但这个服务框架究竟如何与业务开发相结合呢？也就是说业务逻辑代码与框架代码之间如何隔离,而不是让框架的功能代码侵入到业务逻辑代码的开发中来?这里通用的做法就是<strong>通过基于配置，由框架提供运行时，动态加载业务代码的方式</strong>。做到这点，只需要约束业务逻辑代码实现相应的接口/基类，然后打包成相应的组件（如jar/dll/so等）提供给框架加载运行即可，类似于java servlet的开发，业务开发完全不用关心服务化框架任何功能，专注开发业务逻辑即可。同时，对于既有代码的服务化也将变得简单，只需要稍加重构封装出实现相应的接口即可。</p>
<p>配置类似于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">serviceName</span>=<span class="value">"Customer.GetCustomer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">biz</span> <span class="attribute">imp</span>=<span class="value">"com.customer.getCustomer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">biz</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时，这种基于组件配置的服务实现，对于组合组件实现服务也非常简单。只需要将上面的配置改为嵌套的方式既可以实现组合。比如对于订单生成服务只要组合如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">serviceName</span>=<span class="value">"Order.CreateOrder"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">biz</span> <span class="attribute">imp</span>=<span class="value">"com.inventory.checkInventory"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">biz</span> <span class="attribute">imp</span>=<span class="value">"com.order.createOrder"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">biz</span> <span class="attribute">imp</span>=<span class="value">"com.inventory.updateInventory"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">biz</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">biz</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">biz</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>基本来看，服务化架构已经在业界完成了落地，尤其是互联网公司，更是基于这一架构的领先者，有许多经验值得借鉴。当然，这个落地的服务化架构，与当年被各大商业公司用WS-*和ESB玩坏的SOA概念相去甚远。也再一次证明，那些被鼓吹出来的技术概念，只有当那些商业公司不再炒作之时，方是其真正落地之日（SOA如此，当今热炒的“大数据”，“云计算”这些概念又何尝不会是如此呢？）。在技术被鼓吹得风头正劲时，千万要保持冷静，别被那些商业公司所忽悠,你完全可以自己实现更轻量级更具有扩展性的架构。不信的话，可以去问问，那些当年花大价钱去买SOA商业组件的公司，他们还好吗？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/08/02/浅谈服务化架构/" data-id="cipdywfv8000tm7spupvg6zmg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务化/">服务化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面对喷子明哲保身" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/27/面对喷子明哲保身/" class="article-date">
  <time datetime="2014-07-27T15:57:23.000Z" itemprop="datePublished">2014-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/27/面对喷子明哲保身/">面对喷子明哲保身</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>本打算本周继续写关于技术的话题，但是今天碰到一件闲事，让我改了想法！我得写一篇“教化”的文字，你们暂且读读，个人牢骚，慎重评论！
</code></pre><p>先从今天这件“闲事”说起：</p>
<p>最近，我在玩一个群聊App，可以让附近的人加入到同一感兴趣的话题的群里，一起聊想法和观点！我建了一个叫“哲学家”的群，写了句介绍大概意思是说“这里不欢迎思考懒惰者”。本来是无意之举，没想到，还真吸引了小小几十个人的加入。我懒得打理，群里也一向平静如常。而今天，一人在群里发了一个很大的话题：</p>
<pre><code>你们对王阳明的心学怎么看？
</code></pre><p>这话题大的根本无从聊起，而我又觉得难得有人发起讨论，不想因为话题太大无从讨论而冷掉，于是准备将话题缩小到王阳明的“知行合一”的观点上来。于是隐晦的回复了一个类比：</p>
<pre><code>妓女可以谈贞操，因为是过来人，能懂得有和没有的区别;而处女不能谈性技，处女啥都不会，谈什么性技，她连谈贞操的资格也没有！
——喷下“理学”而已，别戴帽子！
</code></pre><p>我本以为，问问题者如果懂得王阳明的知行合一学说，懂得其对程朱理学者“灭人欲”的批判的话，应该能看懂我回答此话的类比之意！而没想到，可能是我回答的太晦涩，还是类比的太悬浮，其给出的回话完全出于我所料，其答：</p>
<pre><code>群主真是好牛逼啊，从贞操谈到性技谈到理学？敢问何为理学？理学和性技有何相关？
</code></pre><p>这种断章取义的回应真是“如雷贯耳”，也似曾熟悉，网络上到处充斥着这种牛头不对马嘴的讨论！我一时无法答上话！沉默良久后，我回答：</p>
<pre><code>第一，你问的王阳明，所以我将王阳明的知行合一说作个类比，表示我赞成它关于知行合一的学说以及其对程朱理学的虚伪理论的批判;

第二，贞操和性技之事，是程朱理学最为避讳而自己却无法做到之事，用其“讽”理学，并无不妥！
</code></pre><p>而后，又有另外一个人回答：</p>
<pre><code>读过几本破书，就敢对理学大放厥词，装什么逼啊！
</code></pre><p>看到这样的回答，我嘴里的水直接喷了出来，这么快就人身攻击了，完全出乎我意料！我赶紧停止了讨论！</p>
<p>闲事至此，我悲从中来，这些人的嘴脸如此熟悉！在国内的网络上，总有一大群人，根本不理解提出观点者其本身的意思，就<strong>断章取义对观点提出者，以其当时心情为标杆，随意对观点提出者进行毫无原则的人身攻击</strong>。他们不知道，说出的每句话背后是需要深刻思考的，他们的头脑或许根本不能支持其去思考！他们只是需要一个情绪排泄的通道，就像排泄物在肚子里需要排出来一样，他们脑子里的排泄物也必须要排出来。</p>
<p>要进行一场正常的观点交碰，是如此的困难！任何观点，只要稍微“左一点”或“右一点”，哪怕是完全的”中立“观点，必将有人以一副“你敢再说？老子弄死你”的流氓嘴脸出现！他们不去思考给出的观点的本质是什么，或者其根本就不具有辨识观点本质的认知能力，可他们有着满腔“鸡血”，非让你进入”地狱“永不翻身才满意！<strong>他们可以满嘴的”自由“，但是他们不能给你发表观点的”自由“;他们可以满怀”善良与人性“，却可以将你全家老小问候一个遍</strong>。对于这类人，我们已经不能称其为”愤青“了，因为”愤青“们反的只是保守言行，而这类人，不管左中右，逮着就喷，无观念，无廉耻，无底线地！用网络上的名词，暂且称其为”喷子“。</p>
<p>我想，如果杀人不犯法的话，他们肯定把你找出来立马弄死！在这样的一个环境里，你需要吃了雄心豹子胆才敢”挑事“，没那承受力的话，就最好明哲保身少说话，或者与这群人为伍，让”伟大的群体“给予你安全保护。为了安宁的生存，你就得放弃你的自由。这就好像鲁迅先生的形象描述：<strong>既然猴子可以变人，为什么现在的猴子不想变人呢？并非都不想变人，也有少数猴子想变人，它们曾经两条腿站起来，学人走路并且说它们想做人。然而它们的同类不允许，说它违背了猴子的本性，把它们咬死了！</strong>。</p>
<p>有时候，我还想左一点的认为，咱们就别搞义务教育了！让那么多喷子学会的文字，却只能被他们用来行这些对社会进步有害而无益之事，到底有何意义呢？还不如让这些人根本不识字不会写字，他们就没法喷了！我甚至违心的去认为，”洗脑”是对的，因为<strong>对于满脑子都是排泄物的人，洗脑或许有益健康</strong>，至少能让他们有原则的守护其观点吧！但回头想想，这样或许是违背子自由教育或自由意志的，我不能这样持双重观点，否则，我不也跟”喷子“无异了吗？</p>
<p><strong>人立身？以为何？我想最起码就是独立思考之能力以及统一与一致的价值观！</strong>而这些”喷子“们，最为缺少的就是这两项基本的素质！这两项素质的缺乏，是无药可治的！因为能治其病的前提，是其必须先具有两项素质，这就成了一个”蛋生鸡鸡生蛋“的问题，不会有治疗方案了。所以，在此，对于这个现象，除了牢骚，我给不出任何根治良方！或许像我这样，碰到这类人，乖乖的躲起来，以免他们的排泄物脏到自己！听之任之，任其放肆与疯狂,就暂且是最好的办法了！</p>
<p>这真是一个悲剧，意味着我们不会再有一个安宁之日了！明哲保身吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sharecore.net/2014/07/27/面对喷子明哲保身/" data-id="cipdywfuk0000m7spslex7wel" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/常识/">常识</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复杂性/">复杂性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/常识/">常识</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/春秋/">春秋</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务化/">服务化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式匹配/">模式匹配</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/13/不平则鸣/">不平则鸣</a>
          </li>
        
          <li>
            <a href="/2016/06/13/人言无可畏/">人言无可畏</a>
          </li>
        
          <li>
            <a href="/2016/06/13/设计的思考/">设计的思考</a>
          </li>
        
          <li>
            <a href="/2016/06/13/解决问题的思路/">解决问题的思路</a>
          </li>
        
          <li>
            <a href="/2016/06/13/I-O模型基本介绍/">I/O模型基本介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 J.H<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="http://weibo.com/justinhuang" class="mobile-nav-link">微博</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>