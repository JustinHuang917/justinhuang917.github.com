<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Go并发编程模式进阶 | ShareCore</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go并发编程模式进阶</h1><a id="logo" href="/.">ShareCore</a><p class="description">Justin.H</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首頁</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="http://weibo.com/justinhuang"><i class="fa fa-user"> 關於</i></a><a href="/atom.xml"><i class="fa fa-rss"> 訂閱</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go并发编程模式进阶</h1><div class="post-meta">Jun 10, 2013<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>前段时间Google的<a href="http://profiles.google.com/ajmani" target="_blank" rel="external">Sameer Ajmani</a>在Google I/O上做了关于Go的并发模式的介绍。Slides<a href="http://talks.golang.org/2013/advconc.slide" target="_blank" rel="external">在此</a>,youtube视频<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=QDDwwePbDtw" target="_blank" rel="external">在此</a>(注：上述链接均需翻墙)。</p>
<p>本篇的前提是对goroutine+channel的并发编程模式有基本的了解，建议能读懂下面这个经典ping-pong程序为好。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义一个结构</span></span><br><span class="line"><span class="keyword">type</span> Ball <span class="keyword">struct</span>&#123; hits <span class="typename">int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="comment">//创建一个可传输Ball的channel</span></span><br><span class="line">	table := <span class="built_in">make</span>(<span class="keyword">chan</span> *Ball)</span><br><span class="line">	<span class="comment">//分别启动ping/pong的goroutine </span></span><br><span class="line">	<span class="keyword">go</span> Player(<span class="string">"Ping"</span>, table)</span><br><span class="line">	<span class="keyword">go</span> Player(<span class="string">"Pong"</span>, table)</span><br><span class="line">	<span class="comment">//一个Ball进入channel，游戏开始</span></span><br><span class="line">	table &lt;- <span class="built_in">new</span>(Ball)</span><br><span class="line">	<span class="comment">//“主”程序暂停1s,等待ping/pong的goroutine执行</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="comment">//从channel取出Ball，游戏开始</span></span><br><span class="line">	&lt;-table</span><br><span class="line">	<span class="comment">//可通过引发异常，显示调用栈的详细信息</span></span><br><span class="line">	<span class="comment">//panic("show me the stacks")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Player(name <span class="typename">string</span>, table <span class="keyword">chan</span> *Ball) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="comment">//channel取出Ball，并hits++</span></span><br><span class="line">	    ball := &lt;-table</span><br><span class="line">	    ball.hits++</span><br><span class="line">	    fmt.Println(name, ball.hits)</span><br><span class="line">	    <span class="comment">//暂停1ms</span></span><br><span class="line">	    time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">	    <span class="comment">//将Ball放回channel</span></span><br><span class="line">	    table &lt;- ball</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ping-pong程序的执行过程，可以用下图来表示。</p>
<p><img src="/images/advgoroutine/pingpong.png" alt="ping-pong程序执行过程"></p>
<p>接下来主要说说Go的并发编程里的一些“文艺”使用:如何通信?如何周期性处理事件？如何取消执行？这些高级用法的支持，除了依赖我们上面看到的goroutine+channel外，还要依赖于Go的一个statement：select+case。它可以用来管理和监听多个channel,从而起到“多路复用”的效果。他的基本语法如下。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">	<span class="keyword">case</span> xc &lt;- <span class="string">x:</span></span><br><span class="line">		<span class="comment">// 向channel(xc)发送一个对象(x)</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">y :</span>= &lt;-<span class="string">yc:</span></span><br><span class="line">		<span class="comment">// 从channel(yc)获取一个对象并赋值到变量(y)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们以一个能持续从RSS获取资源项的例子来说明select的使用。<br>假设我们已经拥有下面这个接口所定义的功能：从一个RSS url获取资源项目(一次调用，获取一次,这个接口的模拟实现，见附1。)<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">Fetcher</span> interface <span class="container">&#123;</span><br><span class="line">	<span class="type">Fetch</span>() (<span class="title">items</span> []<span class="type">Item</span>, <span class="title">next</span> <span class="title">time</span>.<span class="type">Time</span>, <span class="title">err</span> <span class="title">error</span>)//能从某个<span class="title">rss</span> <span class="title">url</span>获取它的资源项，并能同时返回下一次获取的时间<span class="title">next</span>。</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>`我们用下面这个接口来表示我们希望达到的功能：能从rss url上循环获取资源项，形成资源流的形式；循环获取功能，可以中止。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">Subscription</span> interface <span class="container">&#123;</span><br><span class="line">	<span class="type">Updates</span>() &lt;-<span class="title">chan</span> <span class="type">Item</span>//用<span class="title">channel</span>来存放资源，即可实现流的显示</span><br><span class="line">	<span class="type">Close</span>() <span class="title">error</span>//关闭获取</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>先看一个这项功能的简单实现，熟悉多线程编程的，应该觉得很眼熟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> NavieSub <span class="keyword">struct</span> &#123;</span><br><span class="line">	closed  <span class="typename">bool</span></span><br><span class="line">	err     error</span><br><span class="line">	updates <span class="keyword">chan</span> Item</span><br><span class="line">	fetcher Fetcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (s *NavieSub) Close() error &#123;</span><br><span class="line">	s.closed = <span class="constant">true</span><span class="comment">//设置关闭标识为true</span></span><br><span class="line">	<span class="keyword">return</span> s.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (s *NavieSub) Updates() &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	<span class="keyword">return</span> s.updates<span class="comment">//返回已经获取的资源项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (s *NavieSub) loop() &#123;<span class="comment">//循环获取的方法实现</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> s.closed &#123;<span class="comment">//判断关闭标识</span></span><br><span class="line">	        <span class="built_in">close</span>(s.updates)<span class="comment">//close是内置函数</span></span><br><span class="line">	        <span class="keyword">return</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    items, next, err := s.fetcher.Fetch()<span class="comment">//执行一次获取</span></span><br><span class="line">	    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">	        s.err = err</span><br><span class="line">	        time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	        <span class="keyword">continue</span><span class="comment">//出错时暂停10秒后再开始下次循环</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;<span class="comment">//将获取的资源项写入，用于返回</span></span><br><span class="line">	        s.updates &lt;- item</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> now := time.Now(); next.After(now) &#123;<span class="comment">//暂停到下次获取时间时，再开始下一次获取</span></span><br><span class="line">	        time.Sleep(next.Sub(now))</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fetcher := &amp;FakeFether&#123;channel: <span class="string">"sharecore.info"</span>&#125;</span><br><span class="line">	s := &amp;NavieSub&#123;</span><br><span class="line">	    fetcher: fetcher,</span><br><span class="line">	    updates: <span class="built_in">make</span>(<span class="keyword">chan</span> Item),</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> s.loop()<span class="comment">//启动一个例程执行loop方法（与启动一个线程类似）</span></span><br><span class="line">	</span><br><span class="line">	time.AfterFunc(<span class="number">3</span>*time.Second, <span class="keyword">func</span>() &#123;</span><br><span class="line">	    fmt.Println(<span class="string">"closed"</span>, s.Close())</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> s.Updates() &#123;</span><br><span class="line">	    fmt.Println(item.Channel, item.Title)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`那以上的简单实现，会有什么问题呢？</p>
<p>首先，<strong>明显发现s.err和s.closed的访问是非同步的。</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.closed = <span class="constant">true</span> <span class="comment">//设置关闭标识为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.closed &#123;<span class="comment">//判断关闭标识</span></span><br><span class="line">	        <span class="built_in">close</span>(s.updates) <span class="comment">//close是内置函数</span></span><br><span class="line">	        <span class="keyword">return</span></span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure></p>
<p>`然后，我们看到s.updates的定义如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;NavieSub&#123;</span><br><span class="line">	    fetcher: fetcher,</span><br><span class="line">	    updates: <span class="built_in">make</span>(<span class="keyword">chan</span> Item),<span class="comment">//定义为没有buffer的channel，一个channel中同时只能有一个元素</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>`根据上面的定义，s.updates一次只能有一个item进入，当它没有其他goroutine从它里面取出元素时，下面这行代码会<strong>发生堵塞</strong>。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s<span class="class">.updates</span> &lt;- item</span><br></pre></td></tr></table></figure></p>
<p>`那以上问题我们有什么办法来避免呢？</p>
<a id="more"></a>
<p>对于第一个问题，自然想到的解决办法是加锁，但加锁的方式太不符合Go的“口味”了，同时，加锁的方式，在面对比较复杂的并发场景时，容易导致各类由“锁”引发的问题，这也是线程模型的“恶魔”了。</p>
<p>对于第二个问题，普通的办法时当然是将s.updates定义为一个带buffer的channel。但是buffer定义为多大才合适呢？当取出元素的routine太慢，还是一样可能会导致buffer满了，发生堵塞。</p>
<p>下面，我们来看看如何用一个比较“文艺”的办法来解决上面的问题吧。前面我们提到的select这时可以派上用场了。select的机制实现，差不多可以称为是“事件驱动”的，当然这里的“事件”并不是我们平常其他的事件驱动模型里常看到的I/O，网络请求／响应这样的“事件”，而是监听channel变更的“事件”。</p>
<p>将select与for循环结合起来，可以构造持续监听channel的结构，如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func(s *AdvSub) loop()&#123;</span><br><span class="line">	<span class="comment">//可变状态的定义</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">	    <span class="comment">//设置不同的channel的监听case</span></span><br><span class="line">	    select&#123;</span><br><span class="line">	    <span class="keyword">case</span> &lt;-<span class="string">c1:</span></span><br><span class="line">	        <span class="comment">// 读／写状态</span></span><br><span class="line">	    <span class="keyword">case</span> &lt;-<span class="string">c2:</span></span><br><span class="line">	        <span class="comment">// 读／写状态</span></span><br><span class="line">	    <span class="keyword">case</span> <span class="string">y:</span>&lt;-<span class="string">c3:</span></span><br><span class="line">	        <span class="comment">// 读／写状态</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先来看怎么利用for-select结构来解决第一个close同步的问题：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AdvSub <span class="keyword">struct</span>&#123;</span><br><span class="line">	closing <span class="keyword">chan</span> <span class="keyword">chan</span> error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>`如上代码所示，我们给sub定义，加了一个“状态”——closing,而我们就可以利用for-select结构来监听从closing的“状态变化”。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">//close方法，</span></span><br><span class="line">func (s *AdvSub) <span class="keyword">Close</span>() <span class="keyword">error</span>&#123;</span><br><span class="line">	errc:=make(chan <span class="keyword">error</span>)</span><br><span class="line">	 	s.closing&lt;-errc</span><br><span class="line">	 	<span class="keyword">return</span> &lt;-errc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span><span class="comment">//错误状态信息</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		select&#123;</span><br><span class="line">	case errc:=&lt;-s.closing<span class="comment">//当Close方法调用时会触发</span></span><br><span class="line">		errc&lt;-<span class="keyword">err</span><span class="comment">//将错误信息放到Close返回的channel</span></span><br><span class="line">	<span class="keyword">close</span>(s.updates)</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用这种方式，同步的实现是完全依赖且只依赖于channel的同步机制的，这是可以信赖的。</p>
<p>对于第二个问题，我们可以给sub在加一个状态，比如队列，用来保持它已经获到的资源项。如下代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pending []item<span class="comment">//存入新获取的资源(Fetch方法调时)，并同时被消费(Update()被调用，取出元素时)</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">	<span class="keyword">select</span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> s.updates&lt;-pending[<span class="number">0</span>]:</span><br><span class="line">	        pending=pending[<span class="number">1</span>:]<span class="comment">//取出后将第一个元素移除，更新状态</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可是你会发现，上面的代码这么修改后并不会如期的正常运行,而是出现如下的错误：<br><img src="/images/advgoroutine/updateserror.png" alt="s.updates获取错误"></p>
<p>这是因为，一开始pending数组是空的，当执行s.updates&lt;-pending[0]时，会抛出数组越界的异常。<br>我们可以采取下面的方式来解决这个问题：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pending []item</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> first Item</span><br><span class="line">	    <span class="keyword">var</span> updates <span class="keyword">chan</span> Item</span><br><span class="line">	    <span class="keyword">if</span> <span class="built_in">len</span>(pending) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	        first = pending[<span class="number">0</span>]</span><br><span class="line">	        updates = s.updates</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">select</span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> updates&lt;-first:</span><br><span class="line">	        pending=pending[<span class="number">1</span>:]</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面，我们通过for-select结构，解决了同步的问题和堵塞的问题。在NavieSub的loop实现中，我们发现有time.Sleep的调用，对于time.Sleep的模式，我们其实也可以通过for-select结构来解决，这得益于<strong>time包下的许多方法／状态，也提供了返回channel的方式来便于监听</strong>，比如time.After(duration),time.Ticker等。所以我们就可以方便地将time.Sleep去掉，整合到for-select的结构中来<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pending []Item</span><br><span class="line"><span class="keyword">var</span> next time.Time</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fetchDelay time.Duration <span class="comment">//下次获取的延迟时间，默认是0（无延迟）</span></span><br><span class="line">    <span class="keyword">if</span> now:=time.Now();next.After(now)&#123;</span><br><span class="line">        fetchDelay=next.Sub(now)<span class="comment">//计算延迟时间    </span></span><br><span class="line">    &#125;</span><br><span class="line">    startFetch:=time.After(fetchDelay)<span class="comment">//startFetch是一个channnel,时间到达后，会被写入</span></span><br><span class="line">    select &#123;</span><br><span class="line">        case startFetch:<span class="comment">//到达下一次获取时间</span></span><br><span class="line">        <span class="keyword">var</span> fetched []Item</span><br><span class="line">        fetched,next,<span class="keyword">err</span>=s.fetcher.Fetch()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">err</span>!=nil&#123;</span><br><span class="line">            next=time.Now().Add(10*time.Sencond)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        pending=<span class="keyword">append</span>(pending,fetched...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于以上三种情况，我们总结起来的for-select实现代码就如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (s *AdvSub) loop() &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> next time.Time</span><br><span class="line">	<span class="keyword">var</span> pending []Item</span><br><span class="line">	<span class="comment">//综合了三种情况的for-select结构</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="keyword">var</span> fetchDelay time.Duration</span><br><span class="line">	    <span class="keyword">if</span> now := time.Now(); next.After(now) &#123;</span><br><span class="line">	        fetchDelay = next.Sub(now)</span><br><span class="line">	    &#125;</span><br><span class="line">	    startFetch := time.After(fetchDelay)</span><br><span class="line">	    <span class="keyword">var</span> first Item</span><br><span class="line">	    <span class="keyword">var</span> updates <span class="keyword">chan</span> Item</span><br><span class="line">	    <span class="keyword">if</span> <span class="built_in">len</span>(pending) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	        first = pending[<span class="number">0</span>]</span><br><span class="line">	        updates = s.updates</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">select</span> &#123;</span><br><span class="line">	    <span class="keyword">case</span> errc := &lt;-s.closing:<span class="comment">//关闭</span></span><br><span class="line">	        errc &lt;- err</span><br><span class="line">	        <span class="built_in">close</span>(s.updates)</span><br><span class="line">	        <span class="keyword">return</span></span><br><span class="line">	    <span class="keyword">case</span> &lt;-startFetch:<span class="comment">//获取资源</span></span><br><span class="line">	        <span class="keyword">var</span> fetched []Item</span><br><span class="line">	        fetched, next, err = s.fetcher.Fetch()</span><br><span class="line">	        <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">	            next = time.Now().Add(<span class="number">10</span> * time.Second)</span><br><span class="line">	            <span class="keyword">break</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        pending = <span class="built_in">append</span>(pending, fetched...)</span><br><span class="line">	    <span class="keyword">case</span> updates &lt;- first:<span class="comment">//取出资源</span></span><br><span class="line">	        pending = pending[<span class="number">1</span>:]</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，分别附上Fetcher接口的模拟实现，以及普通方式和for-select结构方式的完整实现代码。</p>
<h2 id="附1：Fetcher接口的一个实现">附1：Fetcher接口的一个实现</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Item struct &#123;</span><br><span class="line">	Title, Channel, GUID <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">type FakeFether struct &#123;</span><br><span class="line">	channel <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">items</span>   []Item</span><br><span class="line">&#125;</span><br><span class="line">func (f *FakeFether) Fetch() (<span class="keyword">items</span> []Item, next <span class="built_in">time</span>.Time, err error) &#123;</span><br><span class="line">	now := <span class="built_in">time</span>.Now()</span><br><span class="line">	next = now.Add(<span class="built_in">time</span>.Duration(rand.Intn(<span class="number">5</span>)) * <span class="number">500</span> * <span class="built_in">time</span>.Millisecond)</span><br><span class="line">	<span class="keyword">item</span> := Item&#123;</span><br><span class="line">	    Channel: f.channel,</span><br><span class="line">	    Title:   fmt.Sprintf(<span class="string">"Item %d"</span>, <span class="built_in">len</span>(f.<span class="keyword">items</span>)),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">item</span>.GUID = <span class="keyword">item</span>.Channel + <span class="string">"/"</span> + <span class="keyword">item</span>.Title</span><br><span class="line">	f.<span class="keyword">items</span> = append(f.<span class="keyword">items</span>, <span class="keyword">item</span>)</span><br><span class="line">	<span class="keyword">items</span> = []Item&#123;<span class="keyword">item</span>&#125;</span><br><span class="line">	<span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附2:普通方式完整实现">附2:普通方式完整实现</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item struct &#123;</span><br><span class="line">	Title, Channel, GUID <span class="literal">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Fetcher interface &#123;</span><br><span class="line">	Fetch() (tems []Item, next time.Time, <span class="keyword">err</span> <span class="keyword">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Subscription interface &#123;</span><br><span class="line">	Updates() &lt;-chan Item</span><br><span class="line">	<span class="keyword">Close</span>() <span class="keyword">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FakeFether struct &#123;</span><br><span class="line">	channel <span class="literal">string</span></span><br><span class="line">	items   []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *FakeFether) Fetch() (items []Item, next time.Time, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	next = now.Add(time.Duration(rand.Intn(5)) * 500 * time.Millisecond)</span><br><span class="line">	item := Item&#123;</span><br><span class="line">	    Channel: f.channel,</span><br><span class="line">	    Title:   fmt.Sprintf(<span class="string">"Item %d"</span>, len(f.items)),</span><br><span class="line">	&#125;</span><br><span class="line">	item.GUID = item.Channel + <span class="string">"/"</span> + item.Title</span><br><span class="line">	f.items = <span class="keyword">append</span>(f.items, item)</span><br><span class="line">	items = []Item&#123;item&#125;</span><br><span class="line">	<span class="literal">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NaiveSub struct &#123;</span><br><span class="line">	closed  bool</span><br><span class="line">	<span class="keyword">err</span>     <span class="keyword">error</span></span><br><span class="line">	updates chan Item</span><br><span class="line">	fetcher Fetcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *NaiveSub) <span class="keyword">Close</span>() <span class="keyword">error</span> &#123;</span><br><span class="line">	s.closed = true</span><br><span class="line">	<span class="keyword">return</span> s.<span class="keyword">err</span></span><br><span class="line">&#125;</span><br><span class="line">func (s *NaiveSub) Updates() &lt;-chan Item &#123;</span><br><span class="line">	<span class="keyword">return</span> s.updates</span><br><span class="line">&#125;</span><br><span class="line">func (s *NaiveSub) loop() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> s.closed &#123;</span><br><span class="line">	        <span class="keyword">close</span>(s.updates)</span><br><span class="line">	        <span class="literal">return</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    items, next, <span class="keyword">err</span> := s.fetcher.Fetch()</span><br><span class="line">	    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">	        s.<span class="keyword">err</span> = <span class="keyword">err</span></span><br><span class="line">	        time.<span class="keyword">Sleep</span>(10 * time.Second)</span><br><span class="line">	        <span class="keyword">continue</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">	        s.updates &lt;- item</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> now := time.Now(); next.After(now) &#123;</span><br><span class="line">	        time.<span class="keyword">Sleep</span>(next.Sub(now))</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NaiveMerge struct &#123;</span><br><span class="line">	subs    []Subscription</span><br><span class="line">	updates chan Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">m</span> *NaiveMerge) <span class="keyword">Close</span>() (<span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, sub := <span class="keyword">range</span> <span class="keyword">m</span>.subs &#123;</span><br><span class="line">	    <span class="keyword">if</span> <span class="keyword">e</span> := sub.<span class="keyword">Close</span>(); <span class="keyword">err</span> == nil &amp;&amp; <span class="keyword">e</span> != nil &#123;</span><br><span class="line">	        <span class="keyword">err</span> = <span class="literal">e</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">close</span>(<span class="keyword">m</span>.updates)</span><br><span class="line">	<span class="literal">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">m</span> *NaiveMerge) Updates() &lt;-chan Item &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">m</span>.updates</span><br><span class="line">&#125;</span><br><span class="line">func <span class="keyword">Merge</span>(subs ...Subscription) Subscription &#123;</span><br><span class="line">	<span class="keyword">m</span> := &amp;NaiveMerge&#123;</span><br><span class="line">	    subs:    subs,</span><br><span class="line">	    updates: make(chan Item),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, sub := <span class="keyword">range</span> subs &#123;</span><br><span class="line">	    go func(s Subscription) &#123;</span><br><span class="line">	        <span class="keyword">for</span> it := <span class="keyword">range</span> s.Updates() &#123;</span><br><span class="line">	            <span class="keyword">m</span>.updates &lt;- it</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;(sub)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Subscripbe(fetcher Fetcher) Subscription &#123;</span><br><span class="line">	s := &amp;NaiveSub&#123;</span><br><span class="line">	    fetcher: fetcher,</span><br><span class="line">	    updates: make(chan Item),</span><br><span class="line">	&#125;</span><br><span class="line">	go s.loop()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fetcher1 := &amp;FakeFether&#123;channel: <span class="string">"sharecore.info"</span>&#125;</span><br><span class="line">	fetcher2 := &amp;FakeFether&#123;channel: <span class="string">"blog.golang.org"</span>&#125;</span><br><span class="line">	fetcher3 := &amp;FakeFether&#123;channel: <span class="string">"googleblog.blogspot.com"</span>&#125;</span><br><span class="line">	fetcher4 := &amp;FakeFether&#123;channel: <span class="string">"googledevelopers.blogspot.com"</span>&#125;</span><br><span class="line">	<span class="keyword">m</span> := <span class="keyword">Merge</span>(Subscripbe(fetcher1), Subscripbe(fetcher2), Subscripbe(fetcher3), Subscripbe(fetcher4))</span><br><span class="line">	time.AfterFunc(3*time.Second, func() &#123;</span><br><span class="line">	    fmt.Println(<span class="string">"closed:"</span>, <span class="keyword">m</span>.<span class="keyword">Close</span>())</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> <span class="keyword">m</span>.Updates() &#123;</span><br><span class="line">	    fmt.Println(item.Channel, item.Title)</span><br><span class="line">	&#125;</span><br><span class="line">	panic(<span class="string">"show me the stacks"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附3:for-select结构的完整实现">附3:for-select结构的完整实现</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="comment">//  "errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item struct &#123;</span><br><span class="line">	Title, Channel, GUID <span class="literal">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Fetcher interface &#123;</span><br><span class="line">	Fetch() (tems []Item, next time.Time, <span class="keyword">err</span> <span class="keyword">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Subscription interface &#123;</span><br><span class="line">	<span class="keyword">Update</span>() &lt;-chan Item</span><br><span class="line">	<span class="keyword">Close</span>() <span class="keyword">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FakeFether struct &#123;</span><br><span class="line">	channel <span class="literal">string</span></span><br><span class="line">	items   []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *FakeFether) Fetch() (items []Item, next time.Time, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	next = now.Add(time.Duration(rand.Intn(5)) * 500 * time.Millisecond)</span><br><span class="line">	item := Item&#123;</span><br><span class="line">	    Channel: f.channel,</span><br><span class="line">	    Title:   fmt.Sprintf(<span class="string">"Item %d"</span>, len(f.items)),</span><br><span class="line">	&#125;</span><br><span class="line">	item.GUID = item.Channel + <span class="string">"/"</span> + item.Title</span><br><span class="line">	f.items = <span class="keyword">append</span>(f.items, item)</span><br><span class="line">	items = []Item&#123;item&#125;</span><br><span class="line">	<span class="literal">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdvSub struct &#123;</span><br><span class="line">	closed  bool</span><br><span class="line">	<span class="keyword">err</span>     <span class="keyword">error</span></span><br><span class="line">	updates chan Item</span><br><span class="line">	fetcher Fetcher</span><br><span class="line">	closing chan chan <span class="keyword">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *AdvSub) <span class="keyword">Close</span>() <span class="keyword">error</span> &#123;</span><br><span class="line">	errc := make(chan <span class="keyword">error</span>)</span><br><span class="line">	s.closing &lt;- errc</span><br><span class="line">	<span class="keyword">err</span> := &lt;-errc</span><br><span class="line">	fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">&#125;</span><br><span class="line">func (s *AdvSub) <span class="keyword">Update</span>() &lt;-chan Item &#123;</span><br><span class="line">	<span class="keyword">return</span> s.updates</span><br><span class="line">&#125;</span><br><span class="line">func (s *AdvSub) loop() &#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></span><br><span class="line">	<span class="keyword">var</span> next time.Time</span><br><span class="line">	<span class="keyword">var</span> pending []Item</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="keyword">var</span> fetchDelay time.Duration</span><br><span class="line">	    <span class="keyword">if</span> now := time.Now(); next.After(now) &#123;</span><br><span class="line">	        fetchDelay = next.Sub(now)</span><br><span class="line">	    &#125;</span><br><span class="line">	    startFetch := time.After(fetchDelay)</span><br><span class="line">	    <span class="keyword">var</span> first Item</span><br><span class="line">	    <span class="keyword">var</span> updates chan Item</span><br><span class="line">	    <span class="keyword">if</span> len(pending) &gt; 0 &#123;</span><br><span class="line">	        first = pending[0]</span><br><span class="line">	        updates = s.updates</span><br><span class="line">	    &#125;</span><br><span class="line">	    select &#123;</span><br><span class="line">	    case errc := &lt;-s.closing:</span><br><span class="line">	        errc &lt;- <span class="keyword">err</span></span><br><span class="line">	        <span class="keyword">close</span>(s.updates)</span><br><span class="line">	        <span class="literal">return</span></span><br><span class="line">	    case &lt;-startFetch:</span><br><span class="line">	        <span class="keyword">var</span> fetched []Item</span><br><span class="line">	        fetched, next, <span class="keyword">err</span> = s.fetcher.Fetch()</span><br><span class="line">	        <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">	            next = time.Now().Add(10 * time.Second)</span><br><span class="line">	            <span class="keyword">break</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        pending = <span class="keyword">append</span>(pending, fetched...)</span><br><span class="line">	    case updates &lt;- first:</span><br><span class="line">	        pending = pending[1:]</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NaiveMerge struct &#123;</span><br><span class="line">	subs    []Subscription</span><br><span class="line">	updates chan Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">m</span> *NaiveMerge) <span class="keyword">Close</span>() (<span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, sub := <span class="keyword">range</span> <span class="keyword">m</span>.subs &#123;</span><br><span class="line">	    <span class="keyword">if</span> <span class="keyword">e</span> := sub.<span class="keyword">Close</span>(); <span class="keyword">err</span> == nil &amp;&amp; <span class="keyword">e</span> != nil &#123;</span><br><span class="line">	        <span class="keyword">err</span> = <span class="literal">e</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">close</span>(<span class="keyword">m</span>.updates)</span><br><span class="line">	<span class="literal">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">m</span> *NaiveMerge) <span class="keyword">Update</span>() &lt;-chan Item &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">m</span>.updates</span><br><span class="line">&#125;</span><br><span class="line">func <span class="keyword">Merge</span>(subs ...Subscription) Subscription &#123;</span><br><span class="line">	<span class="keyword">m</span> := &amp;NaiveMerge&#123;</span><br><span class="line">	    subs:    subs,</span><br><span class="line">	    updates: make(chan Item),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, sub := <span class="keyword">range</span> subs &#123;</span><br><span class="line">	    go func(s Subscription) &#123;</span><br><span class="line">	        <span class="keyword">for</span> it := <span class="keyword">range</span> s.<span class="keyword">Update</span>() &#123;</span><br><span class="line">	            <span class="keyword">m</span>.updates &lt;- it</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;(sub)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Subscripbe(fetcher Fetcher) Subscription &#123;</span><br><span class="line">	s := &amp;AdvSub&#123;</span><br><span class="line">	    fetcher: fetcher,</span><br><span class="line">	    updates: make(chan Item),</span><br><span class="line">	    closing: make(chan chan <span class="keyword">error</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	go s.loop()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fetcher1 := &amp;FakeFether&#123;channel: <span class="string">"sharecore.info"</span>&#125;</span><br><span class="line">	fetcher2 := &amp;FakeFether&#123;channel: <span class="string">"blog.golang.org"</span>&#125;</span><br><span class="line">	fetcher3 := &amp;FakeFether&#123;channel: <span class="string">"googleblog.blogspot.com"</span>&#125;</span><br><span class="line">	fetcher4 := &amp;FakeFether&#123;channel: <span class="string">"googledevelopers.blogspot.com"</span>&#125;</span><br><span class="line">	<span class="keyword">m</span> := <span class="keyword">Merge</span>(Subscripbe(fetcher1), Subscripbe(fetcher2), Subscripbe(fetcher3), Subscripbe(fetcher4))</span><br><span class="line">	time.AfterFunc(3*time.Second, func() &#123;</span><br><span class="line">	    fmt.Println(<span class="string">"closed:"</span>, <span class="keyword">m</span>.<span class="keyword">Close</span>())</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> <span class="keyword">m</span>.<span class="keyword">Update</span>() &#123;</span><br><span class="line">	    fmt.Println(item.Channel, item.Title)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("show me the stacks")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://sharecore.net/2013/06/10/Go并发编程模式进阶/" data-id="ciqrh6cuf0031xnspl3u2iky5" class="article-share-link">分享至</a><div class="tags"><a href="/tags/Golang/">Golang</a><a href="/tags/技术/">技术</a></div><div class="post-nav"><a href="/2013/06/29/春秋五霸之首——齐桓公的故事/" class="pre">春秋五霸之首——齐桓公的故事</a><a href="/2013/03/17/Container的安装与使用介绍/" class="next">Linux Container的安装与使用介绍</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://sharecore.net"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分類</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 標籤</i></div><div class="tagcloud"><a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a><a href="/tags/常识/" style="font-size: 15px;">常识</a><a href="/tags/技术常识/" style="font-size: 15px;">技术常识</a><a href="/tags/架构/" style="font-size: 15px;">架构</a><a href="/tags/算法/" style="font-size: 15px;">算法</a><a href="/tags/历史/" style="font-size: 15px;">历史</a><a href="/tags/学习/" style="font-size: 15px;">学习</a><a href="/tags/服务化/" style="font-size: 15px;">服务化</a><a href="/tags/技术/" style="font-size: 15px;">技术</a><a href="/tags/模式匹配/" style="font-size: 15px;">模式匹配</a><a href="/tags/春秋/" style="font-size: 15px;">春秋</a><a href="/tags/Golang/" style="font-size: 15px;">Golang</a><a href="/tags/读书/" style="font-size: 15px;">读书</a><a href="/tags/测试/" style="font-size: 15px;">测试</a><a href="/tags/复杂性/" style="font-size: 15px;">复杂性</a><a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/16/懷才不遇/">懷才不遇？</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/讀張五常談思考方法/">讀張五常談思考方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/22/超越辯論的價值/">超越辯論的價值</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/電子閱讀的問題反思/">電子閱讀的問題反思</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/讀點王陽明/">讀點王陽明</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/文字之殤/">文字之殤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/勿增實體/">勿增實體</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/不平则鸣/">不平则鸣</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/人言无可畏/">人言无可畏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/设计的思考/">设计的思考</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友站連結</i></div><ul></ul><a href="http://weibo.com/justinhuang" title="微博" target="_blank">微博</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ShareCore.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>