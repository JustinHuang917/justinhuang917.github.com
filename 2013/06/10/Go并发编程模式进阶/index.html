<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Go并发编程模式进阶 | ShareCore</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go并发编程模式进阶</h1><a id="logo" href="/.">ShareCore</a><p class="description">Justin.H</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首頁</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="http://weibo.com/justinhuang"><i class="fa fa-user"> 關於</i></a><a href="/atom.xml"><i class="fa fa-rss"> 訂閱</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go并发编程模式进阶</h1><div class="post-meta">Jun 10, 2013<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>前段时间Google的<a href="http://profiles.google.com/ajmani" target="_blank" rel="external">Sameer Ajmani</a>在Google I/O上做了关于Go的并发模式的介绍。Slides<a href="http://talks.golang.org/2013/advconc.slide" target="_blank" rel="external">在此</a>,youtube视频<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=QDDwwePbDtw" target="_blank" rel="external">在此</a>(注：上述链接均需翻墙)。</p>
<p>本篇的前提是对goroutine+channel的并发编程模式有基本的了解，建议能读懂下面这个经典ping-pong程序为好。<br>``` go<br>package main</p>
<p>import (<br>    “fmt”<br>    “time”<br>)<br>//定义一个结构<br>type Ball struct{ hits int }</p>
<p>func main() {<br>    //创建一个可传输Ball的channel<br>    table := make(chan <em>Ball)<br>    //分别启动ping/pong的goroutine<br>    go Player(“Ping”, table)<br>    go Player(“Pong”, table)<br>    //一个Ball进入channel，游戏开始<br>    table &lt;- new(Ball)<br>    //“主”程序暂停1s,等待ping/pong的goroutine执行<br>    time.Sleep(1 </em> time.Second)<br>    //从channel取出Ball，游戏开始<br>    &lt;-table<br>    //可通过引发异常，显示调用栈的详细信息<br>    //panic(“show me the stacks”)<br>}</p>
<p>func Player(name string, table chan *Ball) {<br>    for {<br>        //channel取出Ball，并hits++<br>        ball := &lt;-table<br>        ball.hits++<br>        fmt.Println(name, ball.hits)<br>        //暂停1ms<br>        time.Sleep(1 * time.Millisecond)<br>        //将Ball放回channel<br>        table &lt;- ball<br>    }<br>} </p>
<p>```</p>
<p>ping-pong程序的执行过程，可以用下图来表示。</p>
<p><img src="/images/advgoroutine/pingpong.png" alt="ping-pong程序执行过程"></p>
<p>接下来主要说说Go的并发编程里的一些“文艺”使用:如何通信?如何周期性处理事件？如何取消执行？这些高级用法的支持，除了依赖我们上面看到的goroutine+channel外，还要依赖于Go的一个statement：select+case。它可以用来管理和监听多个channel,从而起到“多路复用”的效果。他的基本语法如下。<br>``` go<br>select {<br>case xc \&lt;- x:<br>    // 向channel(xc)发送一个对象(x)<br>case y := \&lt;-yc:<br>    // 从channel(yc)获取一个对象并赋值到变量(y)<br>}<br>```<br>下面我们以一个能持续从RSS获取资源项的例子来说明select的使用。<br>假设我们已经拥有下面这个接口所定义的功能：从一个RSS url获取资源项目(一次调用，获取一次,这个接口的模拟实现，见附1。)<br>``` go<br>type Fetcher interface {<br>    Fetch() (items []Item, next time.Time, err error)//能从某个rss url获取它的资源项，并能同时返回下一次获取的时间next。<br>}<br>```<br>我们用下面这个接口来表示我们希望达到的功能：能从rss url上循环获取资源项，形成资源流的形式；循环获取功能，可以中止。</p>
<p>``` go<br>type Subscription interface {<br>    Updates() &lt;-chan Item//用channel来存放资源，即可实现流的显示<br>    Close() error//关闭获取<br>}<br>```<br>先看一个这项功能的简单实现，熟悉多线程编程的，应该觉得很眼熟。</p>
<p>``` go </p>
<p>type NavieSub struct {<br>    closed  bool<br>    err     error<br>    updates chan Item<br>    fetcher Fetcher<br>}</p>
<p>func (s *NavieSub) Close() error {<br>    s.closed = true//设置关闭标识为true<br>    return s.err<br>}<br>func (s *NavieSub) Updates() \&lt;-chan Item {<br>    return s.updates//返回已经获取的资源项<br>}<br>func (s *NavieSub) loop() {//循环获取的方法实现<br>    for {<br>        if s.closed {//判断关闭标识<br>            close(s.updates)//close是内置函数<br>            return<br>        }<br>        items, next, err := s.fetcher.Fetch()//执行一次获取<br>        if err != nil {<br>            s.err = err<br>            time.Sleep(10 * time.Second)<br>            continue//出错时暂停10秒后再开始下次循环<br>        }<br>        for _, item := range items {//将获取的资源项写入，用于返回<br>            s.updates &lt;- item<br>        }<br>        if now := time.Now(); next.After(now) {//暂停到下次获取时间时，再开始下一次获取<br>            time.Sleep(next.Sub(now))<br>        }<br>    }<br>}</p>
<p>func main() {<br>    fetcher := &amp;FakeFether{channel: “sharecore.info”}<br>    s := &amp;NavieSub{<br>        fetcher: fetcher,<br>        updates: make(chan Item),<br>    }</p>
<pre><code>go s.loop(<span class="comment">)//启动一个例程执行loop方法（与启动一个线程类似）</span>

<span class="built_in">time</span>.AfterFunc(<span class="number">3</span>*<span class="built_in">time</span>.Second, func() {
    fmt.Println(<span class="string">"closed"</span>, s.Close())
})

<span class="keyword">for</span> <span class="keyword">item</span> := range s.Updates() {
    fmt.Println(<span class="keyword">item</span>.Channel, <span class="keyword">item</span>.Title)
}
</code></pre><p>}<br>```<br>那以上的简单实现，会有什么问题呢？</p>
<p>首先，<strong>明显发现s.err和s.closed的访问是非同步的。</strong><br>``` go<br>s.closed = true //设置关闭标识为true</p>
<p>if s.closed {//判断关闭标识<br>            close(s.updates) //close是内置函数<br>            return<br>        }<br>```<br>然后，我们看到s.updates的定义如下:<br>``` go<br>s := &amp;NavieSub{<br>        fetcher: fetcher,<br>        updates: make(chan Item),//定义为没有buffer的channel，一个channel中同时只能有一个元素<br>    }<br>```<br>根据上面的定义，s.updates一次只能有一个item进入，当它没有其他goroutine从它里面取出元素时，下面这行代码会<strong>发生堵塞</strong>。<br>``` go<br>s.updates \&lt;- item<br>```<br>那以上问题我们有什么办法来避免呢？</p>
<a id="more"></a>
<p>对于第一个问题，自然想到的解决办法是加锁，但加锁的方式太不符合Go的“口味”了，同时，加锁的方式，在面对比较复杂的并发场景时，容易导致各类由“锁”引发的问题，这也是线程模型的“恶魔”了。</p>
<p>对于第二个问题，普通的办法时当然是将s.updates定义为一个带buffer的channel。但是buffer定义为多大才合适呢？当取出元素的routine太慢，还是一样可能会导致buffer满了，发生堵塞。</p>
<p>下面，我们来看看如何用一个比较“文艺”的办法来解决上面的问题吧。前面我们提到的select这时可以派上用场了。select的机制实现，差不多可以称为是“事件驱动”的，当然这里的“事件”并不是我们平常其他的事件驱动模型里常看到的I/O，网络请求／响应这样的“事件”，而是监听channel变更的“事件”。</p>
<p>将select与for循环结合起来，可以构造持续监听channel的结构，如下：<br>``` go<br>func(s *AdvSub) loop(){<br>    //可变状态的定义<br>    for{<br>        //设置不同的channel的监听case<br>        select{<br>        case &lt;-c1:<br>            // 读／写状态<br>        case &lt;-c2:<br>            // 读／写状态<br>        case y:&lt;-c3:<br>            // 读／写状态<br>        }<br>    }<br>}<br>```<br>我们先来看怎么利用for-select结构来解决第一个close同步的问题：<br>``` go<br>type AdvSub struct{<br>    closing chan chan error<br>}<br>```<br>如上代码所示，我们给sub定义，加了一个“状态”——closing,而我们就可以利用for-select结构来监听从closing的“状态变化”。<br>``` go<br>//close方法，<br>func (* s AdvSub) Close() error{<br>    errc:=make(chan error)<br>    s.closing&lt;-errc<br>    return &lt;-errc<br>}</p>
<p>var err error//错误状态信息<br>for{<br>    select{<br>        case errc:=&lt;-s.closing//当Close方法调用时会触发<br>            errc&lt;-err//将错误信息放到Close返回的channel<br>            close(s.updates)<br>            return<br>    }<br>}<br>```<br>采用这种方式，同步的实现是完全依赖且只依赖于channel的同步机制的，这是可以信赖的。</p>
<p>对于第二个问题，我们可以给sub在加一个状态，比如队列，用来保持它已经获到的资源项。如下代码：<br>``` go<br>var pending []item//存入新获取的资源(Fetch方法调时)，并同时被消费(Update()被调用，取出元素时)<br>for{<br>    select{<br>        case s.updates&lt;-pending[0]:<br>            pending=pending[1:]//取出后将第一个元素移除，更新状态<br>    }<br>}<br>```<br>可是你会发现，上面的代码这么修改后并不会如期的正常运行,而是出现如下的错误：<br><img src="/images/advgoroutine/updateserror.png" alt="s.updates获取错误"></p>
<p>这是因为，一开始pending数组是空的，当执行s.updates\&lt;-pending[0]时，会抛出数组越界的异常。<br>我们可以采取下面的方式来解决这个问题：<br>``` go<br>var pending []item<br>for{<br>        var first Item<br>        var updates chan Item<br>        if len(pending) &gt; 0 {<br>            first = pending[0]<br>            updates = s.updates<br>        }<br>        select{<br>        case updates&lt;-first:<br>            pending=pending[1:]<br>        }<br>}<br>```</p>
<p>上面，我们通过for-select结构，解决了同步的问题和堵塞的问题。在NavieSub的loop实现中，我们发现有time.Sleep的调用，对于time.Sleep的模式，我们其实也可以通过for-select结构来解决，这得益于<strong>time包下的许多方法／状态，也提供了返回channel的方式来便于监听</strong>，比如time.After(duration),time.Ticker等。所以我们就可以方便地将time.Sleep去掉，整合到for-select的结构中来<br>``` go<br>    var pending []Item<br>    var next time.Time<br>    var err error<br>    for{<br>        var fetchDelay time.Duration //下次获取的延迟时间，默认是0（无延迟）<br>        if now:=time.Now();next.After(now){<br>            fetchDelay=next.Sub(now)//计算延迟时间<br>        }<br>        startFetch:=time.After(fetchDelay)//startFetch是一个channnel,时间到达后，会被写入<br>        select {<br>            case startFetch://到达下一次获取时间<br>            var fetched []Item<br>            fetched,next,err=s.fetcher.Fetch()<br>            if err!=nil{<br>                next=time.Now().Add(10*time.Sencond)<br>                break<br>            }<br>            pending=append(pending,fetched…)<br>        }<br>    }<br>```</p>
<p>对于以上三种情况，我们总结起来的for-select实现代码就如下：<br>``` go<br>func (s *AdvSub) loop() {<br>    var err error<br>    var next time.Time<br>    var pending []Item<br>    //综合了三种情况的for-select结构<br>    for {<br>        var fetchDelay time.Duration<br>        if now := time.Now(); next.After(now) {<br>            fetchDelay = next.Sub(now)<br>        }<br>        startFetch := time.After(fetchDelay)<br>        var first Item<br>        var updates chan Item<br>        if len(pending) &gt; 0 {<br>            first = pending[0]<br>            updates = s.updates<br>        }<br>        select {<br>        case errc := &lt;-s.closing://关闭<br>            errc &lt;- err<br>            close(s.updates)<br>            return<br>        case &lt;-startFetch://获取资源<br>            var fetched []Item<br>            fetched, next, err = s.fetcher.Fetch()<br>            if err != nil {<br>                next = time.Now().Add(10 * time.Second)<br>                break<br>            }<br>            pending = append(pending, fetched…)<br>        case updates &lt;- first://取出资源<br>            pending = pending[1:]<br>        }<br>    }<br>}<br>```<br>最后，分别附上Fetcher接口的模拟实现，以及普通方式和for-select结构方式的完整实现代码。</p>
<p><em>附1：Fetcher接口的一个实现</em><br>``` go<br>type Item struct {<br>    Title, Channel, GUID string<br>}<br>type FakeFether struct {<br>    channel string<br>    items   []Item<br>}<br>func (f *FakeFether) Fetch() (items []Item, next time.Time, err error) {<br>    now := time.Now()<br>    next = now.Add(time.Duration(rand.Intn(5)) <em> 500 </em> time.Millisecond)<br>    item := Item{<br>        Channel: f.channel,<br>        Title:   fmt.Sprintf(“Item %d”, len(f.items)),<br>    }<br>    item.GUID = item.Channel + “/“ + item.Title<br>    f.items = append(f.items, item)<br>    items = []Item{item}<br>    return<br>}<br>```</p>
<p><em>附2:普通方式完整实现</em><br>``` go</p>
<p>package main</p>
<p>import (<br>    “fmt”<br>    “math/rand”<br>    “time”<br>)</p>
<p>type Item struct {<br>    Title, Channel, GUID string<br>}<br>type Fetcher interface {<br>    Fetch() (tems []Item, next time.Time, err error)<br>}<br>type Subscription interface {<br>    Updates() &lt;-chan Item<br>    Close() error<br>}</p>
<p>type FakeFether struct {<br>    channel string<br>    items   []Item<br>}</p>
<p>func (f *FakeFether) Fetch() (items []Item, next time.Time, err error) {<br>    now := time.Now()<br>    next = now.Add(time.Duration(rand.Intn(5)) <em> 500 </em> time.Millisecond)<br>    item := Item{<br>        Channel: f.channel,<br>        Title:   fmt.Sprintf(“Item %d”, len(f.items)),<br>    }<br>    item.GUID = item.Channel + “/“ + item.Title<br>    f.items = append(f.items, item)<br>    items = []Item{item}<br>    return<br>}</p>
<p>type NaiveSub struct {<br>    closed  bool<br>    err     error<br>    updates chan Item<br>    fetcher Fetcher<br>}</p>
<p>func (s *NaiveSub) Close() error {<br>    s.closed = true<br>    return s.err<br>}<br>func (s *NaiveSub) Updates() \&lt;-chan Item {<br>    return s.updates<br>}<br>func (s *NaiveSub) loop() {<br>    for {<br>        if s.closed {<br>            close(s.updates)<br>            return<br>        }<br>        items, next, err := s.fetcher.Fetch()<br>        if err != nil {<br>            s.err = err<br>            time.Sleep(10 * time.Second)<br>            continue<br>        }<br>        for _, item := range items {<br>            s.updates &lt;- item<br>        }<br>        if now := time.Now(); next.After(now) {<br>            time.Sleep(next.Sub(now))<br>        }<br>    }<br>}</p>
<p>type NaiveMerge struct {<br>    subs    []Subscription<br>    updates chan Item<br>}</p>
<p>func (m *NaiveMerge) Close() (err error) {<br>    for _, sub := range m.subs {<br>        if e := sub.Close(); err == nil &amp;&amp; e != nil {<br>            err = e<br>        }<br>    }<br>    close(m.updates)<br>    return<br>}</p>
<p>func (m *NaiveMerge) Updates() \&lt;-chan Item {<br>    return m.updates<br>}<br>func Merge(subs …Subscription) Subscription {<br>    m := &amp;NaiveMerge{<br>        subs:    subs,<br>        updates: make(chan Item),<br>    }<br>    for _, sub := range subs {<br>        go func(s Subscription) {<br>            for it := range s.Updates() {<br>                m.updates &lt;- it<br>            }<br>        }(sub)<br>    }<br>    return m<br>}</p>
<p>func Subscripbe(fetcher Fetcher) Subscription {<br>    s := &amp;NaiveSub{<br>        fetcher: fetcher,<br>        updates: make(chan Item),<br>    }<br>    go s.loop()<br>    return s<br>}</p>
<p>func main() {<br>    fetcher1 := &amp;FakeFether{channel: “sharecore.info”}<br>    fetcher2 := &amp;FakeFether{channel: “blog.golang.org”}<br>    fetcher3 := &amp;FakeFether{channel: “googleblog.blogspot.com”}<br>    fetcher4 := &amp;FakeFether{channel: “googledevelopers.blogspot.com”}<br>    m := Merge(Subscripbe(fetcher1), Subscripbe(fetcher2), Subscripbe(fetcher3), Subscripbe(fetcher4))<br>    time.AfterFunc(3*time.Second, func() {<br>        fmt.Println(“closed:”, m.Close())<br>    })<br>    for item := range m.Updates() {<br>        fmt.Println(item.Channel, item.Title)<br>    }<br>    panic(“show me the stacks”)<br>}</p>
<p>``` </p>
<p><em>附3:for-select结构的完整实现：</em><br>``` go<br>package main</p>
<p>import (<br>    //  “errors”<br>    “fmt”<br>    “math/rand”<br>    “time”<br>)</p>
<p>type Item struct {<br>    Title, Channel, GUID string<br>}<br>type Fetcher interface {<br>    Fetch() (tems []Item, next time.Time, err error)<br>}<br>type Subscription interface {<br>    Update() &lt;-chan Item<br>    Close() error<br>}</p>
<p>type FakeFether struct {<br>    channel string<br>    items   []Item<br>}</p>
<p>func (f *FakeFether) Fetch() (items []Item, next time.Time, err error) {<br>    now := time.Now()<br>    next = now.Add(time.Duration(rand.Intn(5)) <em> 500 </em> time.Millisecond)<br>    item := Item{<br>        Channel: f.channel,<br>        Title:   fmt.Sprintf(“Item %d”, len(f.items)),<br>    }<br>    item.GUID = item.Channel + “/“ + item.Title<br>    f.items = append(f.items, item)<br>    items = []Item{item}<br>    return<br>}</p>
<p>type AdvSub struct {<br>    closed  bool<br>    err     error<br>    updates chan Item<br>    fetcher Fetcher<br>    closing chan chan error<br>}</p>
<p>func (s *AdvSub) Close() error {<br>    errc := make(chan error)<br>    s.closing &lt;- errc<br>    err := &lt;-errc<br>    fmt.Println(err)<br>    return err<br>}<br>func (s *AdvSub) Update() \&lt;-chan Item {<br>    return s.updates<br>}<br>func (s *AdvSub) loop() {<br>    var err error<br>    var next time.Time<br>    var pending []Item</p>
<pre><code><span class="keyword">for</span> {
    var fetchDelay <span class="built_in">time</span>.Duration
    <span class="keyword">if</span> <span class="built_in">now</span> := <span class="built_in">time</span>.<span class="built_in">Now</span>(); <span class="keyword">next</span>.After(<span class="built_in">now</span>) {
        fetchDelay = <span class="keyword">next</span>.<span class="keyword">Sub</span>(<span class="built_in">now</span>)
    }
    startFetch := <span class="built_in">time</span>.After(fetchDelay)
    var first Item
    var updates chan Item
    <span class="keyword">if</span> <span class="built_in">len</span>(pending) &gt; <span class="number">0</span> {
        first = pending[<span class="number">0</span>]
        updates = s.updates
    }
    <span class="keyword">select</span> {
    <span class="keyword">case</span> errc := &lt;-s.closing:
        errc &lt;- <span class="built_in">err</span>
        close(s.updates)
        return
    <span class="keyword">case</span> &lt;-startFetch:
        var fetched []Item
        fetched, <span class="keyword">next</span>, <span class="built_in">err</span> = s.fetcher.Fetch()
        <span class="keyword">if</span> <span class="built_in">err</span> != nil {
            <span class="keyword">next</span> = <span class="built_in">time</span>.<span class="built_in">Now</span>().Add(<span class="number">10</span> * <span class="built_in">time</span>.<span class="built_in">Second</span>)
            break
        }
        pending = append(pending, fetched...)
    <span class="keyword">case</span> updates &lt;- first:
        pending = pending[<span class="number">1</span>:]
    }
}
</code></pre><p>}</p>
<p>type NaiveMerge struct {<br>    subs    []Subscription<br>    updates chan Item<br>}</p>
<p>func (m *NaiveMerge) Close() (err error) {<br>    for _, sub := range m.subs {<br>        if e := sub.Close(); err == nil &amp;&amp; e != nil {<br>            err = e<br>        }<br>    }<br>    close(m.updates)<br>    return<br>}</p>
<p>func (m *NaiveMerge) Update() \&lt;-chan Item {<br>    return m.updates<br>}<br>func Merge(subs …Subscription) Subscription {<br>    m := &amp;NaiveMerge{<br>        subs:    subs,<br>        updates: make(chan Item),<br>    }<br>    for _, sub := range subs {<br>        go func(s Subscription) {<br>            for it := range s.Update() {<br>                m.updates &lt;- it<br>            }<br>        }(sub)<br>    }<br>    return m<br>}</p>
<p>func Subscripbe(fetcher Fetcher) Subscription {<br>    s := &amp;AdvSub{<br>        fetcher: fetcher,<br>        updates: make(chan Item),<br>        closing: make(chan chan error),<br>    }<br>    go s.loop()<br>    return s<br>}</p>
<p>func main() {<br>    fetcher1 := &amp;FakeFether{channel: “sharecore.info”}<br>    fetcher2 := &amp;FakeFether{channel: “blog.golang.org”}<br>    fetcher3 := &amp;FakeFether{channel: “googleblog.blogspot.com”}<br>    fetcher4 := &amp;FakeFether{channel: “googledevelopers.blogspot.com”}<br>    m := Merge(Subscripbe(fetcher1), Subscripbe(fetcher2), Subscripbe(fetcher3), Subscripbe(fetcher4))<br>    time.AfterFunc(3*time.Second, func() {<br>        fmt.Println(“closed:”, m.Close())<br>    })<br>    for item := range m.Update() {<br>        fmt.Println(item.Channel, item.Title)<br>    }<br>    //panic(“show me the stacks”)<br>}</p>
<p>```</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://sharecore.net/2013/06/10/Go并发编程模式进阶/" data-id="cipo1llwu002vt2spf2m4na50" class="article-share-link">分享至</a><div class="tags"><a href="/tags/Golang/">Golang</a><a href="/tags/技术/">技术</a></div><div class="post-nav"><a href="/2013/06/29/春秋五霸之首——齐桓公的故事/" class="pre">春秋五霸之首——齐桓公的故事</a><a href="/2013/03/17/Container的安装与使用介绍/" class="next">Linux Container的安装与使用介绍</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://sharecore.net"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分類</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 標籤</i></div><div class="tagcloud"><a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a><a href="/tags/常识/" style="font-size: 15px;">常识</a><a href="/tags/技术常识/" style="font-size: 15px;">技术常识</a><a href="/tags/架构/" style="font-size: 15px;">架构</a><a href="/tags/算法/" style="font-size: 15px;">算法</a><a href="/tags/历史/" style="font-size: 15px;">历史</a><a href="/tags/学习/" style="font-size: 15px;">学习</a><a href="/tags/服务化/" style="font-size: 15px;">服务化</a><a href="/tags/技术/" style="font-size: 15px;">技术</a><a href="/tags/模式匹配/" style="font-size: 15px;">模式匹配</a><a href="/tags/春秋/" style="font-size: 15px;">春秋</a><a href="/tags/Golang/" style="font-size: 15px;">Golang</a><a href="/tags/读书/" style="font-size: 15px;">读书</a><a href="/tags/测试/" style="font-size: 15px;">测试</a><a href="/tags/复杂性/" style="font-size: 15px;">复杂性</a><a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/電子閱讀的問題反思/">電子閱讀的問題反思</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/讀點王陽明/">讀點王陽明</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/文字之殤/">文字之殤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/勿增實體/">勿增實體</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/不平则鸣/">不平则鸣</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/人言无可畏/">人言无可畏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/设计的思考/">设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/解决问题的思路/">解决问题的思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/I-O模型基本介绍/">I/O模型基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/24/天冷讀史/">天冷讀史</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友站連結</i></div><ul></ul><a href="http://weibo.com/justinhuang" title="微博" target="_blank">微博</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ShareCore.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>