<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShareCore</title>
  <subtitle>Justin.H</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sharecore.net/"/>
  <updated>2016-06-19T17:13:11.000Z</updated>
  <id>http://sharecore.net/</id>
  
  <author>
    <name>Justin.H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>讀點王陽明</title>
    <link href="http://sharecore.net/2016/06/20/%E8%AE%80%E9%BB%9E%E7%8E%8B%E9%99%BD%E6%98%8E/"/>
    <id>http://sharecore.net/2016/06/20/讀點王陽明/</id>
    <published>2016-06-19T17:12:13.000Z</published>
    <updated>2016-06-19T17:13:11.000Z</updated>
    
    <content type="html">&lt;p&gt; 下午翻書，讀錢穆老先生的一本小書《陽明學述要》，尚未讀完，只先初步了解了王陽明生前一番經歷。對於陽明心學，只是在術語的字面上，所知一二，如所謂的“致良知”、“知行合一”等等。人總是懶惰的，喜歡用自己的既有的知識和經驗去解釋碰到的新概念，所以對於陽明學的這些概念，我只是用自己固有的經驗去理解，不覺有什麼高深，權當其為無用之學。這番讀書，了解王守仁是在怎樣的一番苦難經歷下，才提煉升華出這幾大哲學概念，甚為欽佩，更望做更為全面之了解。&lt;/p&gt;
&lt;p&gt;陽明生於官宦之家，家境甚優，幼年讀書，十二歲即隨祖父與父親遠宦京師，成長與詩禮之下。少年始，他就興趣甚廣，有著不可羈束的好奇心和浪漫情趣，好與人學各種學說，如新婚夜道士對壘修養生之道竟忘歸，慕功績與豪傑而出塞逐胡兒騎射，修朱熹格物之學格竹子七日而病倒，感慨于邊疆戰事而留心武事，讀盡兵家書等等，實乃一個多方面有趣味之人，在他內心，充滿著一種不可言喻的熱烈追求，一毫不放鬆地往前趕著。但我想，年輕而氣盛時的王陽明，肯定也跟我當下一樣，有著無窮的內驅力，對未知的領域充滿情趣，卻還是苦於不知究竟未來路在何方，在哪條道上可以為“天下第一等事”。&lt;/p&gt;
&lt;p&gt;三十一歲，陽明告病歸故里，這時他又將三十年的壯熱激情收斂起來，選擇離世遠去，遁入靜境。一個在過往生涯中絕不安分之人，能在一念之間選擇出世，那此人真正的品性是好靜的，更是善於認真思考有執著於自己內心之人。我不由思考，一個人無論其表面怎麼喜歡與世有爭，如若他能隨時地安靜地選擇出世的思考，那其境界必將高普通人一等也。&lt;/p&gt;
&lt;p&gt;三十三歲，又選擇重入政界，沒料到這次的政界之旅，是其人生最為重要的經歷，在我們看來，也是苦難的經歷。同時他開始授徒講學，立異好名，雖未成學，也是春風得意之時。只是未料，政治的風雲變化，終是逃不過，朝天閹官把權，良臣遇害，其義氣相救，卻得來詔獄之禍，廷杖四十，謫貶貴州，當了一個小小的驛丞。在貴州瘴疬之地，大病一場，同時還有人暗殺，時時需要警覺，以求保命。可越是在困厄之時，他奮發出極為自在的情態，當他的幾個僕人相繼病倒，他選擇自己服伺僕人，為他們端茶送藥，無居住之室，又教人範土架木而居，沒碰到一個困難，他都積極地去解決，儘管環境變化，但是他還是表露出一貫的人格，還是倔強，還是高興，內心深處還是奮鬥著。而正是在這種複雜的的狀態下，他卻從此發明了他的“格物致知”新學說。&lt;/p&gt;
&lt;p&gt;這一番的了解，讓我對陽明學說另眼相看，不再把它看成是幾個學術名詞而已，他的這些學說背後，是有生命的，是有著人生經歷的，是從很複雜的經驗中演變而來。他說“立志”，說“知行合一”，說“真切”，這一切都要用他的的經歷來下注釋，才能了解他說的意義。而同時，我們若忘了自己的實際生活經歷而空聽他的說話，那所得也還是不切身的，膚淺而已。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 下午翻書，讀錢穆老先生的一本小書《陽明學述要》，尚未讀完，只先初步了解了王陽明生前一番經歷。對於陽明心學，只是在術語的字面上，所知一二，如所謂的“致良知”、“知行合一”等等。人總是懶惰的，喜歡用自己的既有的知識和經驗去解釋碰到的新概念，所以對於陽明學的這些概念，我只是用自
    
    </summary>
    
    
      <category term="历史" scheme="http://sharecore.net/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>文字之殤</title>
    <link href="http://sharecore.net/2016/06/17/%E6%96%87%E5%AD%97%E4%B9%8B%E6%AE%A4/"/>
    <id>http://sharecore.net/2016/06/17/文字之殤/</id>
    <published>2016-06-17T13:22:07.000Z</published>
    <updated>2016-06-17T13:22:39.000Z</updated>
    
    <content type="html">&lt;p&gt;今日讀《破解古文字的故事》，讀完了羅塞塔文字之謎解開的過程。對文字的發展演化形成了一點看法。我一直堅持再用繁體字寫作、寫微博、發朋友圈，在一個周圍人都使用簡體字的環境，這種特立獨行難免會讓人誤會成有裝作之嫌。我一直不屑於給他們解釋我用繁體字的原因，有人問到，只是告訴他們，你們看我用繁體字寫的東西，是學習繁體字的一個機會，要珍惜。&lt;/p&gt;
&lt;p&gt;別人珍惜不珍惜這樣的機會，我當人無法左右，但我卻實實在在地將平常用繁體字寫作當成我認識、銘記繁體字的一個機會，在日常的習慣中去應用，也幫我省掉了集中花大量時間去學習。&lt;/p&gt;
&lt;p&gt;從繁體字激進的改變成簡體字，是一次斷崖式的升級，不符合漢字原來漸進式的進化方式。無論時表音文字，還是表意文字，他們的都會在細節處保留其進化的痕跡。但是漢字的簡化，卻宛如一次激進的基因突變，比如簡體字“马”，如果只看字體，你根本無法再聯想到它原來是表示馬的形體的符號。所有對漢字的認知，完全是依賴於自身的條件反射。&lt;/p&gt;
&lt;p&gt;自然演化之事情，如果因為眼前的短暫利益，採取過度干預的方式，加速其演化的進度，都是不適合的，只是一種致命的自負。短期的利益滿足，一般都是因為獨立看待事情，缺乏了系統化的看待。如漢字簡化，在當時來看，確實可以增加書寫的速度、但是誰能想到，當代計算機技術的發展，書寫速度根本不是問題。反倒是，它丟掉了它的本真，這是卻永遠無法再找回來的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今日讀《破解古文字的故事》，讀完了羅塞塔文字之謎解開的過程。對文字的發展演化形成了一點看法。我一直堅持再用繁體字寫作、寫微博、發朋友圈，在一個周圍人都使用簡體字的環境，這種特立獨行難免會讓人誤會成有裝作之嫌。我一直不屑於給他們解釋我用繁體字的原因，有人問到，只是告訴他們，你
    
    </summary>
    
    
      <category term="历史" scheme="http://sharecore.net/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>勿增實體</title>
    <link href="http://sharecore.net/2016/06/17/%E5%8B%BF%E5%A2%9E%E5%AF%A6%E9%AB%94/"/>
    <id>http://sharecore.net/2016/06/17/勿增實體/</id>
    <published>2016-06-17T13:11:30.000Z</published>
    <updated>2016-06-17T13:12:52.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;em&gt;奧卡姆剃刀原則：如無必要，勿增實體。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;近來思考解決方案，系統設計，在腦海里反思最多的就是這條原則。這一原則，初看來是一句廢話，每個人都知道說，要簡單，不要複雜。很多時候，去跟一個沒經驗的毛頭小子談論，他也會跟你說，簡單就好簡單就好，甚至還會搬出喬布斯來給你說教。而，事實是這些把成天把簡單掛在嘴上的人，大多數是沒經歷過深刻的思考，只為了給自己的思維懶惰找一個藉口而已。&lt;/p&gt;
&lt;p&gt;世界是複雜的，但當然並非是某個特定的實體或者活動是複雜的，而是這些表面上簡單的活動或實體，每一個都有滿足其運行需要的特定要求，把這些簡單的活動和實體聯合在一起，結果就會是複雜和令人困惑的：整體大於各部分的總和。而那些看著單個活動、實體，看不到它們相互之間交合，閉著眼說“簡單就好”的完全是掩耳盜鈴，自欺欺人。&lt;/p&gt;
&lt;p&gt;既然事實如此複雜，那是不是奧卡姆剃刀是一條無用的原則呢？當然不是。在我看來，這條原則的理解上，太多人講注意力放在了“必要”上，而沒看到“實體”。“必要”是一個抽象的意願性描述詞，大多數的時候，因為能契合當下的心理，所以容易吸引多數人的注意，這是自然的。但是深刻思考的人，會將注意力放在“實體”一詞上，會去想什麼是“實體”？“實體”在當下的情況下，是一個什麼樣的定義？缺乏基礎的概念定義，一般是我們爭論和錯誤的罪首。&lt;/p&gt;
&lt;p&gt;如何定義實體，其實就是如何定義事物的邊界，包括兩點：事物運行的特定需求、事物產生的必然效果。一個準確的實體定義，應包括一個盡量小的特定需求集，同時產生一個可以量化的效果。這就好比如計算機程序，如果我們需要能確認這個程序是健壯的，最佳的辦法就是能將他定義成一個最小的輸入條件下滿足一個準確而可量化的結果輸出。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;奧卡姆剃刀原則：如無必要，勿增實體。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;近來思考解決方案，系統設計，在腦海里反思最多的就是這條原則。這一原則，初看來是一句廢話，每個人都知道說，要簡單，不要複雜。很多時候，去跟一個沒經驗的毛頭小子談論，他也會跟你說，簡單就好簡單就好，甚至還會搬
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>不平则鸣</title>
    <link href="http://sharecore.net/2016/06/13/%E4%B8%8D%E5%B9%B3%E5%88%99%E9%B8%A3/"/>
    <id>http://sharecore.net/2016/06/13/不平则鸣/</id>
    <published>2016-06-13T11:49:35.000Z</published>
    <updated>2016-06-16T14:31:54.000Z</updated>
    
    <content type="html">&lt;p&gt;今日读到韩愈的《送孟东野序》一文，为其“不平则鸣”的思想所吸引。源于儒家之传统，向来是习惯遵守仁道，遇不平而忍气吞声的，而韩公作为儒家大师还能有如此不平而鸣之气概，可见其思想的出类拔苹，不与时同。文章开头：大凡物不得其平则鸣…人之于言也亦然，有不得已者而后言。其歌也有思，其哭也有怀，凡出乎口而为声者，其皆有弗平者乎。 说的就是，人遇到不平，必然通过言语表达出来，或将不平写到他得歌与诗里。&lt;/p&gt;
&lt;p&gt;我在《人言无可畏》一文里说的，人都是需要表达的，只是人际关系的道义约束，让人变得不敢言说，将心中的不平与不惑抑制于内心，只待有一个无言语代价的时机，以一种或恶或假或无意义的方式表达出来。但是韩公告诫说，不要做这样的人，他告诉我们，遇到不平，必然用言语作出回响，这是万物必然之理，好比如平静的水面，静立的草木本也无声，但是风吹过他们后，他们必然报以应有的声音作为回应。&lt;/p&gt;
&lt;p&gt;关于韩公的字：退之，有一个故事：说韩公早年，科场屡试不中，偶遇才貌双全卢氏，说起其科场屡次失利的原因，卢氏题字：“人求言实，火求心虚， 欲成大器，必先退之”，韩公沉思，察觉出自己的日常骄傲，缺乏谦虚之情，遂取字“退之”。&lt;/p&gt;
&lt;p&gt;这个故事常用来规劝我们要谦虚为人，而在我看来，这应该是个杜撰的故事，或者说是漏洞百出的故事，因为从韩公后来的文字与为人来看，其一生基本与“退之”绝缘，此“不平则鸣”的《送孟东野序》一文就是例证。其名篇《伯夷颂》更是说：士之特立独行，适于义而已，不顾人之是非，皆豪杰之士，信道笃而自知明也。明显表露出，韩公作为一个有独立思想的读书人不会随波逐流，而是只会按他自己的道义来行事，也不会顾虑他人讲的是是非非，坚持自己的信仰，明明白白自己的为人。如此，坚持个人道义信仰之人，怎可被称为“退之”呢？&lt;/p&gt;
&lt;p&gt;韩公一生推动继承先秦两汉散文的传统，逆当时流行的骈体文之风，以致后被苏轼称为是“文起八代之衰”，足见其敢于挑战潮流之志。韩公又不遗余力推行“师道”，与当时“以为师而耻”的时代风气作对，而在佛、到盛行的大唐，韩公又是一个一生不与佛、道为行，不惧鬼神之人。短短五十多岁的人生，韩公从未“退之”，而是逆流勇进，敢为天下先。&lt;/p&gt;
&lt;p&gt;暂且不论，韩公坚守和奉行的道义之事，以今人眼光来看，是对或错，而其敢于守个人道义，抒不平之意，行不苟合之事，是我们非常缺乏的一种时代精神。我们也许真的没必要对周围不合自己道义的事情过于忍气吞声，也没必要为自己所行之事过多考虑是不是为潮流所容纳，遇不平则鸣，遇不义则逆，这是最符合人性的常情。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今日读到韩愈的《送孟东野序》一文，为其“不平则鸣”的思想所吸引。源于儒家之传统，向来是习惯遵守仁道，遇不平而忍气吞声的，而韩公作为儒家大师还能有如此不平而鸣之气概，可见其思想的出类拔苹，不与时同。文章开头：大凡物不得其平则鸣…人之于言也亦然，有不得已者而后言。其歌也有思，其
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>人言无可畏</title>
    <link href="http://sharecore.net/2016/06/13/%E4%BA%BA%E8%A8%80%E6%97%A0%E5%8F%AF%E7%95%8F/"/>
    <id>http://sharecore.net/2016/06/13/人言无可畏/</id>
    <published>2016-06-13T11:48:11.000Z</published>
    <updated>2016-06-13T11:49:14.000Z</updated>
    
    <content type="html">&lt;p&gt;去年，天津爆炸的悲剧上演，看着鲜活的生命逝去，悲悯之心当然是不能避免的，这是作为善良之辈的常情使然。只是每一次悲惨的事故，最终却会演化成社会、网络上各派力量的针锋相对，彼此猜测和质疑的一幕闹剧，而随着时间慢慢推移，闹剧也会渐渐收场，大家好像突然都健忘了，情绪慢慢收敛，直到下一次的闹剧来临，将平复的情绪导向另一波高潮。而将民众情绪推向高潮的，是那些接连不断，纷然混乱，真伪莫辨的传说，我们当然也很习惯武断地将它定义为：谣言。&lt;/p&gt;
&lt;p&gt;语言是情绪排泄的通道。但我们却是生活在一个没有表达宽容度的环境，一句“人言可畏”吓坏了多少想说话的人。对于身边的事情我们都只能欲言又止，因为大家都习惯了用恶意的眼光看待周围的事物，包括言语。中庸之道横行，对于与己相关的世事，大家都习惯唯唯诺诺，尽量保证与之言语的对方，不会对自己产生恶意的理解，也就是常说的：不在言语上得罪人。可是，信奉中庸平和之道的社会，为何又会“谣言四起”呢？甚至这些“谣言”都是明显带有恶意的。我看原因就出在这中庸之道上的言语尊重。我们对周围人的客气，表达上的唯唯诺诺，灭不掉我们内心深处的表达诉求。当被周遭的人情世故压抑的太久，太多的“怨声载道”不能表达出来时，我们就将所有恶意的猜测与言语，在一次次的事故的风口上一股脑发泄出来。因为这些事故，一般都不与自己的人际关系直接相关，表达假与丑就都变得没有代价。没有代价，同时还能带来情绪排泄的快感 ，性价比很高，那就不如将所有积压的愁怨，一次性的释放出来。所以，整个人际关系对言语的不宽容而造成的全社会表达孤独，是每次“谣言四起”的真正祸根。&lt;/p&gt;
&lt;p&gt;人际之间对表达的不容忍，是几千年来深根于儒家土壤里的一棵毒蘑菇，一时半会，还没法去拔掉它，环境既然改变不了，谣言就必将存在。认识和承认谣言的必然存在性很重要，因为这决定了对待谣言的态度。我想，我们的主权者是没有认识到这一点的，从他们每次针对谣言祭出大棒来棒杀就可以看出其认识上的肤浅性。当谣言威胁到他们时，就成了“人言可畏”，他们过于敏感的神经，必然给出剧烈的反应。须不知，民众的思维向来都是线性的，在民众眼中，主权者反应剧烈的，就是离真相更近的事实，因为他们从来都不会信任任何主权者。而如果主权者能放开忌讳，人言无可畏，那就不会反应过度，而是会去用足够的事实与信息，去击破一个个可能不真实的谣言，也会有足够的诚意，去面对可能是真相的事实。主权者以宽容的姿态接受质疑，相信人言不可畏，另外一个好处就是能引导民众人际之间的表达宽容，缓解全社会的表达孤独。&lt;/p&gt;
&lt;p&gt;我们看似找到了破解谣言的药方，但是却会发现，这个药方，在一个从上至下的制度环境里，并不可行。从上至下，权力集中，哪来的宽容？少数人的决策，利益集中，谁愿改革？我们只能期望，传统的厚积能自身被慢慢被稀释，更加愿意相信人言无可畏，我们的表达孤独能不再被压抑，会有一个人际间表达更宽容的明天。&lt;/p&gt;
&lt;p&gt;应该会有吧？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你的声音我听不见 现在是太吵太乱&lt;br&gt;你已经看了这么长的时间你怎么还不发言&lt;br&gt;是谁出的题这么的难 到处全都是正确答案&lt;br&gt;   ——何勇《钟鼓楼》(歌曲)&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;去年，天津爆炸的悲剧上演，看着鲜活的生命逝去，悲悯之心当然是不能避免的，这是作为善良之辈的常情使然。只是每一次悲惨的事故，最终却会演化成社会、网络上各派力量的针锋相对，彼此猜测和质疑的一幕闹剧，而随着时间慢慢推移，闹剧也会渐渐收场，大家好像突然都健忘了，情绪慢慢收敛，直到下
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>设计的思考</title>
    <link href="http://sharecore.net/2016/06/13/%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://sharecore.net/2016/06/13/设计的思考/</id>
    <published>2016-06-13T11:44:38.000Z</published>
    <updated>2016-06-13T11:47:47.000Z</updated>
    
    <content type="html">&lt;p&gt;今天去一个商场找厕所，发现一个很奇葩的设计，厕所的门口前面有一个大概十米的走廊，从走廊的这一头，抬头可以看到走廊另一头女厕所 的标记，可是男厕所的标记却无法看见。好多位男士跟我一样站在走廊的这一头，不敢往里面走，怕走错进了女厕所。我环顾四周，确实没发现周围还有男厕所，只好冒着胆子往里走，大概走到女厕所的门口，才发现男厕所在我的右手边，它图标却挂在进去的门里，难怪站在走廊那一头，死活发现不了。&lt;/p&gt;
&lt;p&gt;这真是一个让人尴尬和难受的上厕所体验，这样的设计是明显反人类的。在我们的日常生活中，其实到处都充斥着这样的设计，设计者不经思考的设计，让我们原本简单的生活变得复杂与艰难。比如下面的设计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;红灯可右转，在日常生活中，红灯亮后，车辆是不能行使的，现在将规则改成红灯可右转，让右转道上过马路的行人就不知如何是好了，司机和行人的理解误差和时间冲突，更容易造成事故。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;电梯楼层按键，电梯的楼层按键一般设计为每层一个按钮，按钮上得数字表示了相应的楼层。当一栋楼只有10来层的，这还不是什么问题，但当一个楼层超过三十层，在三十个按钮数字里要找到你的目标，这真是对眼力的考验。尤其很多时候，电梯的光线还不充足的情况下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;电视机的遥控，他的按键加起来最少超过20个，一般情况下每个按键都是一个功能，但有的按键的功能超过一个，甚至是几个。所以，如果你要学会使用，就必须记住每个按键代表了哪些功能，还要记住按键之间的操作顺序。&lt;/p&gt;
&lt;p&gt;以上的种种不合理，我们每天的生活都得要顺应接受着，甚至当你不小心违反了它的规则设计，或者根本不会使用某项功能时，还要被歧视，说你掌握的知识不够，或思维反应慢等。可这些糟糕的问题，真的是我们自己的原因造成的吗？显然不是，我们只是不合理设计的受害者，让我们陷入难堪的不是我们自己的愚蠢，是设计者的愚蠢。明白这一点很重要，只有受害者不再“忍气吞声”，才能让设计者多点思考，做出更合理的设计。&lt;/p&gt;
&lt;p&gt;设计中有一条很重要的原则：&lt;strong&gt;可视性&lt;/strong&gt;。它说的是设计出的产品，其正确的操作部位必须是显而易见的，而且能向用户传达正确的信息。而我们上面的厕所走廊设计和电梯按钮设计，显然是违背这一原则的，厕所的走廊，没有将男厕所的标记放在最明显的地方，传达出“这里有男厕所的信息”，才造成了所有男士的尷尬；而电梯的按钮，将正确的按钮藏在一堆按钮之间，并且每个按钮颜色、大小等都是一样的，造成了使用者根本难以找到正确按钮的问题，电视机的遥控也同样如此，功能和按键的不一一对应，导致使用者必须自己记住每个功能的操作，而不是通过按键的提醒就可以完成。&lt;/p&gt;
&lt;p&gt;设计中的另外一条重要设计原则：&lt;strong&gt;匹配&lt;/strong&gt;。匹配原则是指产品的设计必须使用者所在的环境和使用者既存的日常经验是一致的，比如音量的旋转按钮，超右旋转是声音加大，朝左是减小，现在将调节器改成两个按键，那就不能将加大声音的按键放至左侧，减小声音的按键放右侧，因为这跟使用既有的经验传承是不匹配的。上面所说的红灯可右转造成的困扰也是一样不符合匹配原则的，人们日常的认识里就是红灯代表车辆静止的，现在改成可右转行使，必然出现认知的冲突。&lt;/p&gt;
&lt;p&gt;违反可视性和匹配原则的设计，&lt;strong&gt;从认知心理学上来讲，主要是将原来可以通过“系统1”思考(即直觉的快思考)的问题，强迫使用者使用“系统2”思考(即推理性的慢思考)来完成，“系统2”的思考明显是更消耗人类的能量的，所以才会导致使用起来时感到不适。&lt;/strong&gt; 使用者本来也不应该将自己的精力浪费在原来不需要浪费的地方，精力的分散将导致其真正要耗费思考和决策的地方变得低效。为使用者减少不必要的精力浪费，是设计的必尽义务。设计者的思考是具有杠杆作用的，设计者多花一分精力思考，能节省使用者十分的精力。&lt;/p&gt;
&lt;p&gt;告诫自己：多观察日常中不合理的设计，反思自己曾做出的设计，到底是方便了使用者，还是增加了麻烦？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天去一个商场找厕所，发现一个很奇葩的设计，厕所的门口前面有一个大概十米的走廊，从走廊的这一头，抬头可以看到走廊另一头女厕所 的标记，可是男厕所的标记却无法看见。好多位男士跟我一样站在走廊的这一头，不敢往里面走，怕走错进了女厕所。我环顾四周，确实没发现周围还有男厕所，只好冒
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>解决问题的思路</title>
    <link href="http://sharecore.net/2016/06/13/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://sharecore.net/2016/06/13/解决问题的思路/</id>
    <published>2016-06-13T11:42:21.000Z</published>
    <updated>2016-06-13T11:44:06.000Z</updated>
    
    <content type="html">&lt;p&gt;作为一个技术负责人，帮人解决技术难题是一份不能脱责的工作，平常20%的工作时间是在帮人解决问题。解决问题时也常碰到恼火的情况， 而让人恼火的原因不在问题的本身，在于提出问题的方式。提问题的人如果缺乏对问题基本了解，甚至还无法描述出问题，就将问题抛出，那解答问题的人就需要追本溯源，从问题具体是什么开始追问，然后再去一步步的耐心解决，效率明显低下。很多时候，解答问题的人，怎样才能做到授人以渔而不是授人以鱼呢？&lt;/p&gt;
&lt;p&gt;下面主要说说我对解决问题的一些思路：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1.收集足够的信息描述出问题 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是问题？我经常给它定义：问题就是信息不对称。最可怕的不是问题本身，是不知道问题出在哪，而不知道问题出在哪，是因为没有收集关于问题的充足信息。当无法用清晰的方式将问题的现象描述出来，说明信息是不充分的。比如经常被问到一个问题：我昨天的程序还是可以跑起来的，但是今天就不能跑起来了。这个问题的表象就是昨天可以运行的今天不能运行了，如果只能这样的描述问题，显然没有掌握充分信息。需要更多地去收集：今天不能运行是因为抛异常了嘛？异常的描述信息有收集吗？异常描述里的关键字有提取吗？有将这些关键字拿到搜索引擎里去搜索别人关于这个关键字的更详细描述吗？有收集昨天和今天运行环境的变化吗？沿着这个思路，90%的问题都可以找到原因。而当你一股脑将问题抛给有经验的人去解决时，他的思路其实也是如此，一步步搜索关于问题的相关描述信息，只是他们更多的是在他们拥有的经验里快速搜索，所以，他们解决问题的速度会更快。可他们的经验，也是经过长时间信息积累后一步步建立起来的，慢慢从“慢思考”转变为了“快思考”。如果你不去经历这样思路和信息积累过程，将永远只能依赖别人的经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2.学会问问题，掌握问问题的艺术 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人的经验不足，就需要很多地去依赖过来人的经验。但很多时候，有人问一个技术问题，讲了三分钟后，我只能反问他一句：问题是什么？这真是尴尬。其实被问问题的人，他们最需要知道这几件事：问题发生的场景是什么？已经收集到的关于问题描述信息有哪些？希望问题解决后达到的效果什么？需要说清楚问题发生的场景，现象描述以及达到的效果，是因为这三者是解决问题的人从他的经验里搜索和匹配信息的关键，大多数的情况下，人解决问题的依据都是头脑里现存的信息，而如果你问问题的方式，不能快速帮助被问问题者快速匹配信息，那他解决问题的效率跟你是一样的。重要的事情再重申一遍：问题的场景、现象、需要达到的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.努力创造问题重现的环境 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前文说到，90%的问题可以沿着信息搜集的方式找到原因。但是，另外10%的问题，问题的描述信息却不能轻易的搜集到，而需要努力去重现问题发生的场景，一个能重现的问题就是一个好问题。当然，部分问题的场景重现难度，可能是现有能力不能驾驭的，对于这部分问题，当请求他人协助时，不如就直接请求别人协助构建问题重现的环境。而当然，问题如果真的无法重现，只会敦促你更好地去建立跟踪机制，比如程序的日志功能完善等。有些时候，不构建重现问题的环境，通过暴力的手段，也可以将问题暂时绕过，比如重启程序或者重启设备，但是这样的方式只是暂时，不能保证下一次不再发生。当你用了这种暴力手段，甚至有可能导致重现问题的场景变得更加困难。所以，暴力虽好，且用且慎重。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.不制造新的问题 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了足够的问题描述信息，靠自己或者依靠他人的经验，可能就能得到解决方案。但是这时，一定要静心下来想一想，解决方案会不会制造新的问题呢？因为新的解决方案难免要就要对现有的情况实施变更，而只要有变更，就会有发生更严重问题的风险。别让你的解决方案成为新的祸根，铭记海恩法则：每一次严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患！再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个技术负责人，帮人解决技术难题是一份不能脱责的工作，平常20%的工作时间是在帮人解决问题。解决问题时也常碰到恼火的情况， 而让人恼火的原因不在问题的本身，在于提出问题的方式。提问题的人如果缺乏对问题基本了解，甚至还无法描述出问题，就将问题抛出，那解答问题的人就需要追本
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型基本介绍</title>
    <link href="http://sharecore.net/2016/06/13/I-O%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://sharecore.net/2016/06/13/I-O模型基本介绍/</id>
    <published>2016-06-13T11:24:36.000Z</published>
    <updated>2016-06-13T11:41:27.000Z</updated>
    
    <content type="html">&lt;p&gt;作为后台开发，高并发和高性能问题，是最常需要面对的。而解决高并发和高性能问题，选择合适的I/O模型是必由之路。本文将对各种I/O模型作基本介绍，并以相应的java代码实现为例。&lt;/p&gt;
&lt;p&gt;在介绍I/O模型之前，我们需要对操作系统的I/O操作流程有一个基本的了解，继而理解同步\异步、阻塞\非阻塞这两个关于I/O操作的不同概念。对于操作系统I/O操作流程，在这不作详细介绍，具体可以参考《深入理解计算机系统》一书，概要说明以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作系统的运行区间分为用户态和内核态，用户态即用户应用程序运行的运行空间，只能访问有限的内存，不能访问外围I/O设备，如硬盘、网卡等，内核态可以访问所有内存区域以及所有外围I/O设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户态的应用程序访问I/O需要通过发起系统调用，由内核线程(指令)来完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内核线程完成相应I/O操作(读取/写入)，数据需要从内核态复制到用户空间的内存，应用程序从内存获取数据，才能继续完成相应业务逻辑的执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步\异步、阻塞\非阻塞这两个概念经常拿在一起说，容易导致混淆，若不能清晰地理解这两个概念，理解I/O模型也会变得困难。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;:指用户线程发起了I/O请求后，需一直等待或轮询内核I/O操作完成后，才会继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;:指用户线程发起I/O请求后依然继续执行，当内核完成I/O操作后会通知用户线程，或者回调用户线程已注册的回调函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;阻塞&lt;/strong&gt;:指只有内核的I/O操作彻底完成后，才会返回用户空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;非阻塞&lt;/strong&gt;:指I/O操作被调用后，立即返回一个状态值，无需等到I/O操作彻底完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概念上的表述，理解起来可能不太直观，我们以以下的例子来类比说明：&lt;/p&gt;
&lt;p&gt;周末晚上，我去楼下的快餐点打包外卖，点完餐后，老板给了我一张纸质单，让我等会凭这个单子来取外卖，由于我并不知道什么时候外卖能准备后，只能每隔几分钟去前台问一下是否可以了。在等外卖的过程中，我又想去隔壁的甜品店打包一个甜品，点完甜品后，甜品店给了我一个蓝牙电子通知器，在一定范围里，当甜品准备好了，电子通知器会振动，告知我去取甜品即可。所以最后的结果就是，我在快餐店不断询问快餐是否准备好了，同时等着甜品店的电子通知器振动。&lt;/p&gt;
&lt;p&gt;在这个故事里，快餐店接受我的点餐请求后，我并不需要一直等待，还可以去隔壁点甜点，这是一种非阻塞模型，但是我还是需要不断去轮询餐点准备状态，这又是一种同步模型。而甜品店采取主动通知的方式，我并不需要去询问甜品的就绪状态，只需要等待甜品店的主动通知，这是一种典型的异步方式。&lt;/p&gt;
&lt;p&gt;也由此可知，阻塞\非阻塞模型其实都是同步的，而只有采取特需的通知(回调)方式，才能真正实现异步的效果。&lt;br&gt;I/O模型&lt;br&gt;接下来我们基于同步\异步、阻塞\非阻塞的概念，介绍各个I/O模型，并以一个简单的进行socket读写程序的java代码来说明。&lt;/p&gt;
&lt;h2 id=&quot;同步阻塞I/O&quot;&gt;同步阻塞I/O&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;&lt;p&gt;同步阻塞I/O是编程方式最为简单的I/O操作，它是指在用户线程发起I/O操作后，会一直阻塞，直至内核完成I/O操作，将数据复制到用户空间下后才返回继续执行。&lt;/p&gt;
&lt;h3 id=&quot;编程示例&quot;&gt;编程示例&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SyncBlockedEcho&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BufferedReader in=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Socket socket=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServerSocket serverSocket=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            serverSocket =  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 当前用户线程获取socket&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            socket = serverSocket.accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            in = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(socket.getInputStream()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String inputLine;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//阻塞直读取完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((inputLine = in.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(inputLine);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//do close&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同步阻塞I/O作为最简单的一种I/O模型，其最大问题是用户线程在整个I/O操作过程中是被阻塞的，也就是说在I/O操作过程中，用户线程不能做任何事情，而I/O操作并不需要过多CPU参与，也就以为着这种模式对CPU的利用率明显不高。同时当前用户线程由于被阻塞，并不能继续接受新的socket连接，不适合高并发的场景，鉴于此，我们可以采取多线程的模式作为改善。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SyncBlockedThreadPoolEcho&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServerSocket serverSocket=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService pool = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            serverSocket =  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 当前用户线程获取socket&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Socket  socket = serverSocket.accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pool.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            BufferedReader in = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(socket.getInputStream()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            String inputLine;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((inputLine = in.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                System.out.println(inputLine);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ex.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;comment&quot;&gt;//do close&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//do close&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;采用多线程的模式，解决了主线程因为被阻塞而不能接受新连接的问题，同时，由于可以采取线程池之类的技术，避免线程的重复创建、销毁等带来的性能损失，所以具有了更高的并发处理能力。但是这种模式依然受限于I/O操作的同步与阻塞，面对大并发的场景，需要大量的线程来维持连接，而线程越多，会引起内存占用(每个线程都有最小的内存分配要求)、CPU利用率下降(线程之间切换频繁)的问题。&lt;/p&gt;
&lt;h2 id=&quot;同步非阻塞I/O&quot;&gt;同步非阻塞I/O&lt;/h2&gt;&lt;h3 id=&quot;概念-1&quot;&gt;概念&lt;/h3&gt;&lt;p&gt;同步非阻塞I/O是指请求发起后，当前用户线程发起I/O请求后，不会在调用上阻塞，而是立即返回，一般可以通过将socket设置为NONBLOCK的方式来达到此目的。但是由于需要不断地轮询socket的就绪状态，CPU将会浪费在状态轮询上，直到数据就绪，都是无用功。也就是说，当前线程会阻塞在如下的while循环上，实际上起不到真正的非阻塞效果。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(socket.read(buf))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;多路复用&quot;&gt;多路复用&lt;/h3&gt;&lt;p&gt;为了解决这个问题，于是有了I/O多路复用。I/O多路复用建立在操作系统内核提供的select系统调用基础之上，当然他还是需要轮询，只是轮询的对象从socket的就绪状态变为了select系统调用的状态返回，但是他的优势是因为select可以同时返回多个就绪状态的socket，也就是意味着在同一个用户线程，可以同时进行多个I/O请求，而不是上述模型的在单个I/O请求上阻塞，这也是模型概念里“多路”的含义了。我们用以下代码来表述这一特性：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NonBlcokedEcho&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BufferedReader in=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Socket socket=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServerSocket serverSocket=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServerSocketChannel serverChannel = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;  ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Selector selector = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                serverChannel = ServerSocketChannel.open();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ServerSocket innerSocket = serverChannel.socket();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                InetSocketAddress address = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InetSocketAddress(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                innerSocket.bind(address);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//设置socket为非阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                serverChannel.configureBlocking(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                selector = Selector.open();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                serverChannel.register(selector, SelectionKey.OP_ACCEPT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ex.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//发起select调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    selector.select();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ex.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//返回多个就绪状态的socket&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Iterator iterator = keys.iterator() ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//循环处理多个就绪socket&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    SelectionKey key=(SelectionKey)iterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    iterator.remove();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(key.isAcceptable())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;//接受新连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(key.isReadable()&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;//读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(key.isWritable()&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;//写入数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ex.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//do close&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;异步I/O&quot;&gt;异步I/O&lt;/h2&gt;&lt;p&gt;前面说到的I/O模型，无论是阻塞还是非阻塞模型，都是同步的，而真正的异步I/O需要借助以下特殊的系统API来实现，这其中包括Linux下的AIO，windows/.NET下的BeginInvoke/EndInvoke编程模型等等，Java SE 7后也引入NIO的支持。其基本思想是通过告知内核一些上下文状态信息，注册回调函数，当内核完成I/O操作，并将数据复制到缓冲区后，通过唤起回调函数，达到通知应用程序使用数据的效果，由此可见，异步I/O肯定也是非阻塞的。以下以JAVA NIO的代码为例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncEcho&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_PORT = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService taskExecutor = Executors.newCachedThreadPool(Executors.defaultThreadFactory());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AsynchronousServerSocketChannel asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (asynchronousServerSocketChannel.isOpen()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                asynchronousServerSocketChannel.setOption(StandardSocketOptions.SO_RCVBUF, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                asynchronousServerSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                asynchronousServerSocketChannel.bind(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InetSocketAddress(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Waiting for connections ...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Future&amp;lt;AsynchronousSocketChannel&amp;gt; asynchronousSocketChannelFuture = asynchronousServerSocketChannel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            .accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AsynchronousSocketChannel asynchronousSocketChannel = asynchronousSocketChannelFuture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                .get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        Callable&amp;lt;String&amp;gt; worker = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                String host = asynchronousSocketChannel.getRemoteAddress().toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Incoming connection from: &quot;&lt;/span&gt; + host);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ByteBuffer buffer = ByteBuffer.allocateDirect(&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;comment&quot;&gt;// transmitting data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (asynchronousSocketChannel.read(buffer).get() != -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    buffer.flip();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    asynchronousSocketChannel.write(buffer).get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (buffer.hasRemaining()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        buffer.compact();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        buffer.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                asynchronousSocketChannel.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                System.out.println(host + &lt;span class=&quot;string&quot;&gt;&quot; was successfully served!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; host;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        taskExecutor.submit(worker);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       ex.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;The asynchronous server-socket channel cannot be opened!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.err.println(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步/异步与阻塞/非阻塞是两个不同的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阻塞/非阻塞I/O一般都是同步的，而异步I/O一般都是非阻塞的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步I/O要达到并发的效果，一般采用多路复用模型(select/epoll)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步I/O需要系统内核的特别支持，提供异步操作的API。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作为后台开发，高并发和高性能问题，是最常需要面对的。而解决高并发和高性能问题，选择合适的I/O模型是必由之路。本文将对各种I/O模型作基本介绍，并以相应的java代码实现为例。&lt;/p&gt;
&lt;p&gt;在介绍I/O模型之前，我们需要对操作系统的I/O操作流程有一个基本的了解，继而理解
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://sharecore.net/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>天冷讀史</title>
    <link href="http://sharecore.net/2016/01/24/%E5%A4%A9%E5%86%B7%E8%AE%80%E5%8F%B2/"/>
    <id>http://sharecore.net/2016/01/24/天冷讀史/</id>
    <published>2016-01-24T13:29:18.000Z</published>
    <updated>2016-06-17T13:30:14.000Z</updated>
    
    <content type="html">&lt;p&gt;今日的天氣真是冷到了極致，沒有取暖措施，又習慣了暖冬的深圳人，非常不適應，朋友圈都是一片抱怨。我也只好躲在家裡，休息與讀書。心理有個想法，想繼續讀點專業上的書，學些新的技術知識，卻發現遲遲不想行動，真是越來越喪失了專業行動力啊，要想辦法改進了，給自己一個新的目標來激勵自己。&lt;/p&gt;
&lt;p&gt;懶惰的空虛時間，我就只好繼續讀史了，繼續讀呂思勉《三國史話》，今日對他寫的《替魏武帝辯誣》一章有感。魏武帝即曹孟德，儘管在此以其廟號“魏武帝”相稱，但是曹公是一生均為稱帝，魏武帝的廟號是其兒子稱帝追封的。呂公在此章就據曹孟德終身未稱帝為事實，對其公忠、正直與勇敢作了一番評駁。&lt;/p&gt;
&lt;p&gt;常言道，曹孟德”挾天子以令諸侯”，這不是是事實，因為在當時的亂世，天子並沒有任何能約束天下的能力，而各路諸侯也根本不會將天子放在眼裡，這只不過是演義者迎合社會心理的一種戲說而已，而且這種戲說若不是能迎合大多數人的心理，也決不會流傳如此之廣了。以如此不正當的、低下的批評，并不足以識英雄啊！&lt;/p&gt;
&lt;p&gt;曹孟德作為一代梟雄，終生能守護好自己的權慾，這當然有封建制度原有的禮教約束所起的作用，但是也更在於他自身的個人操守，文中列出的事實很多，比如早年曹孟德開始起兵，討伐董卓，本可以連接更多兵力，但他說兵多意盛，和強敵爭衝，反而成為禍始。確實如此，一個人能在自己力量小的時候，或許還能駕馭自己的慾望，但是力量大了，自己的慾望就大了，周遭給的意見也多了，或許就不是自己能駕馭了；再比如他後來破降黃巾三十萬，后有破平袁術、袁紹、劉表，跟人說起這些經過時他又說”設使國家無有孤，不知當幾人稱帝？幾人稱王？”，可見其并無取漢而代之之意，卻又匡扶漢帝之理想。&lt;/p&gt;
&lt;p&gt;我們讀史，更多就是為了獲取歷史的本真事實，以免被世人的演義迷惑了眼，失去了辯駁之力啊。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今日的天氣真是冷到了極致，沒有取暖措施，又習慣了暖冬的深圳人，非常不適應，朋友圈都是一片抱怨。我也只好躲在家裡，休息與讀書。心理有個想法，想繼續讀點專業上的書，學些新的技術知識，卻發現遲遲不想行動，真是越來越喪失了專業行動力啊，要想辦法改進了，給自己一個新的目標來激勵自己。
    
    </summary>
    
    
      <category term="历史" scheme="http://sharecore.net/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配初析</title>
    <link href="http://sharecore.net/2014/08/24/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%9D%E6%9E%90/"/>
    <id>http://sharecore.net/2014/08/24/模式匹配初析/</id>
    <published>2014-08-24T04:58:29.000Z</published>
    <updated>2016-06-13T11:40:46.000Z</updated>
    
    <content type="html">&lt;p&gt;前几天看到篇C#6.0的draft spec，发现C#6.0里将惊现模式匹配。如是便在做了翻宣讲说“模式匹配”是一个很好用的特性，&lt;br&gt;但是不知道跟C#的结合会怎么样。而同时却又发现周边了解“模式匹配”的人好少，于是诞生了写一篇文章稍微介绍下这&lt;br&gt;一功能特性的想法。&lt;/p&gt;
&lt;p&gt;如果说模式匹配这一概念有人不知道，但是正则表达式应该绝大多数的程序员都知道的了。而简言之，模式匹配就是更强大的正则表达式，或者说正则表达式是模式匹配这一概念在字符串处理上的一个应用。有了正则表达式为例，我们可以为模式匹配定义一个更为通用的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;模式匹配是判断输入的数据（信息）是否与特定的结构相匹配，并按模式从中取得数据（信息）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下以正则表达式为例，从输入数据value里按pattern提取数据digits的模式匹配过程。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value=&lt;span class=&quot;string&quot;&gt;&quot;abc123&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern=&lt;span class=&quot;regexp&quot;&gt;/\d/g&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//定义模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; digits=value.match(pattern);&lt;span class=&quot;comment&quot;&gt;//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那更广泛意义上的模式匹配是什么呢？其实很简单，就是输入/提取数据（信息）的范围不再局限为字符串了，甚至可以是编程语言支持的所有数据结构。第一次接触模式匹配这一概念，是前几年学习erlang的时候，下面就主要以erlang为例，来对模式匹配稍作介绍。&lt;/p&gt;
&lt;p&gt;先上点erlang里的”甜点”为例来说明：&lt;/p&gt;
&lt;p&gt;(erlang基础知识：大写字母开头的声明为变量，比如下面例子里的P，H,T;小写字母的声明是原子,比如abc)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;模式{&lt;span class=&quot;function_or_atom&quot;&gt;abc&lt;/span&gt;，&lt;span class=&quot;variable&quot;&gt;P&lt;/span&gt;}与输入数据项{&lt;span class=&quot;function_or_atom&quot;&gt;abc&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;}匹配，并在匹配的同时，发生绑定&lt;span class=&quot;variable&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;arrow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;

模式[&lt;span class=&quot;variable&quot;&gt;H&lt;/span&gt;|&lt;span class=&quot;variable&quot;&gt;T&lt;/span&gt;]与输入数据项[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]匹配，并在匹配的同时，发生绑定&lt;span class=&quot;variable&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;arrow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;variable&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;arrow&quot;&gt;-&amp;gt;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个例子匹配的过程如下：&lt;/p&gt;
&lt;p&gt;1.先进行类型匹配：模式和数据项都是一个元组（“{}”），匹配通过。&lt;/p&gt;
&lt;p&gt;2.模式元组的第一个元素为常量，进行匹配：模式和数据项都是“abc”,匹配通过。&lt;/p&gt;
&lt;p&gt;3.模式元组的第二个元素是一个变量P，同时后面不再有任何元素，结束匹配，并将P绑定到数据项第一个元素后的所有元素。&lt;/p&gt;
&lt;p&gt;第二个例子匹配过程如下：&lt;/p&gt;
&lt;p&gt;1.先进行类型匹配，模式和数据项都是一个列表（“[]”），匹配通过。&lt;/p&gt;
&lt;p&gt;2.模式”[H|T]”表示的是一个“首尾”匹配，用“|”分开两个变量（H，T），H表示的首元素匹配，T表示尾部（除首元素外的所有元素）匹配。匹配是通过的,并绑定H和T的值为首元素和尾元素。&lt;/p&gt;
&lt;p&gt;再来一个高级点的例子：使用模式匹配来处理消息的接收：&lt;/p&gt;
&lt;p&gt;(erlang基础知识：erlang的调用是基于CSP的，各个actor之间通过消息通讯带完成调用;receive原语是erlang提供的消息接收机制，可监听和接收来自其它actor发送来的消息;”！”标识符用于向对应的actor发送消息)。&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;Dict&lt;/span&gt;)&lt;/span&gt; -&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;receive&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;%消息接收的原语，获取调用方的消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tuple&quot;&gt;&amp;#123;store, &lt;span class=&quot;variable&quot;&gt;Key&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;Value&lt;/span&gt;&amp;#125;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;comment&quot;&gt;%匹配数据存储的消息，&quot;store&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;function_name&quot;&gt;loop&lt;/span&gt;(&lt;span class=&quot;function_name&quot;&gt;dict:store&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;Key&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;Value&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;Dict&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;%真实的存储&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tuple&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;From&lt;/span&gt;, &lt;span class=&quot;tuple&quot;&gt;&amp;#123;get, &lt;span class=&quot;variable&quot;&gt;Key&lt;/span&gt;&amp;#125;&lt;/span&gt;&amp;#125;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;comment&quot;&gt;%匹配数据获取的消息, From匹配消息来源，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;variable&quot;&gt;From&lt;/span&gt; ! &lt;span class=&quot;function_name&quot;&gt;dict:fetch&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;Key&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;Dict&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;%向查询请求消息来源发送查询结果消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;function_name&quot;&gt;loop&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;Dict&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;%尾递归：持续监听新的消息 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;Pid&lt;/span&gt; = spawn(loop) &lt;span class=&quot;comment&quot;&gt;%启动一个进程(actor)，Pid为进程号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;Pid&lt;/span&gt;!&lt;span class=&quot;tuple&quot;&gt;&amp;#123;store ,key1,&lt;span class=&quot;string&quot;&gt;&quot;123&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;%向进程发送一个键值对存储消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;Pid&lt;/span&gt;!&lt;span class=&quot;tuple&quot;&gt;&amp;#123;get,key1&amp;#125;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;%发送一个查询消息，获取&quot;key1&quot;对应的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面展示例子模式匹配在erlang中进行消息匹配的使用，需要注意的一点是，这里的匹配是从上到下来进行的，即会先进行“store”的匹配，匹配失败的话才进行“get”匹配。消息匹配是erlang里的一项杀手锏特性，它能大大减少在消息处理的代码量，代码只要专注于实际算法的实现即可，将相应消息的解析和内容提取，交给模式匹配来完成。&lt;/p&gt;
&lt;p&gt;从本质上来讲，模式匹配体现的是一个解构的过程和手段，解构是日常编程过程中一个非常常见的场景，比如编译器将程序代码解析为一个抽象语法树（AST）就是一个解构的过程，再比如，将XML/JSON进行反序列化为程序对象也是一例。对于许多语言，并未提供强大的模式匹配特性，但是为了提供可扩展的解构功能，一般都会采取一些设计模式来解决。比如面向对象编程里，将解析操作抽离出独立的模块，采取基于基类的虚方法/抽象方法扩展的方式，然后结合想对应的规则配置，来完成有区别性的模式解构。但是，这样的方式，稍显笨重，代码量也更多，与模式匹配相比，不在一个复杂度等级之上。&lt;/p&gt;
&lt;p&gt;去年我用golang写了一个web框架，其中的路由解析过程就采取了类似的方式（代码位置：&lt;a href=&quot;https://github.com/JustinHuang917/gof&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/JustinHuang917/gof&lt;/a&gt;）。通过如以下路由规则配置，匹配不同的URL模式，从URL中提取相应的参数：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;RouteRules&quot;:[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &quot;/Order/&amp;#123;id:[0-9]+&amp;#125;&quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#123;&quot;controller&quot;:&quot;Order&quot;,&quot;action&quot;:&quot;Order&quot;,&quot;id&quot;:&quot;0&quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &quot;/&amp;#123;controller&amp;#125;/&amp;#123;action&amp;#125;&quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#123;&quot;controller&quot;:&quot;Home&quot;,&quot;action&quot;:&quot;Index&quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个看似简单功能，我花了200多行代码才得以完成，使用的还是堪称语法最为精简的Golang，而如果使用Java/C#来完成，代码量肯定还要增加不少。而如果语言本身具有强大的模式匹配的话，实现代码将会变得非常精简。而这一次C#6.0声称引入模式匹配，希望是面向对象语言领域的一次有益尝试。&lt;/p&gt;
&lt;p&gt;同时，我也希望我喜欢的Golang在模式匹配上迈开尝试的脚步，在现有的goroutine+channel的组合上应用模式匹配，将是一件非常有效率的实践。现在Golang提供”select..case…“机制只能识别不同channel返回的消息，而不能识别实际消息的内容，这一点来说，与erlang相比，降低了CSP的编程效率。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;模式匹配是来自函数式编程领域的高效的编程功能特性，它能成倍增加“解构”代码的编写效率，明显降低代码复杂度。同时，尽管大多数的编程语言，尚未提供这一功能，但是实际代码编写过程中，我们可以借鉴其基于模式声明的思想，抽离出相应的模式匹配模块，在保证可扩展性的同时，控制数据（信息）匹配带来的代码复杂度。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前几天看到篇C#6.0的draft spec，发现C#6.0里将惊现模式匹配。如是便在做了翻宣讲说“模式匹配”是一个很好用的特性，&lt;br&gt;但是不知道跟C#的结合会怎么样。而同时却又发现周边了解“模式匹配”的人好少，于是诞生了写一篇文章稍微介绍下这&lt;br&gt;一功能特性的想法。&lt;
    
    </summary>
    
    
      <category term="基础知识" scheme="http://sharecore.net/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="模式匹配" scheme="http://sharecore.net/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>字符编码常识及问题解析</title>
    <link href="http://sharecore.net/2014/08/10/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%B8%B8%E8%AF%86%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://sharecore.net/2014/08/10/字符编码常识及问题解析/</id>
    <published>2014-08-10T15:53:04.000Z</published>
    <updated>2015-03-16T16:28:16.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;在面试的笔试题里出了一道开放性的题：请简述&lt;span class=&quot;keyword&quot;&gt;Unicode&lt;/span&gt;与UTF-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几
，确实挺失望的。所以今天就结合我以前做过的一个关于字符编码的分享，总结一些与字符编码相关的知识和问题。如果你这方面的
知识已经掌握的足够了，可以忽略这篇文字。但如果你没法很好的回答我上面的面试题，或经常被乱码的问题所困扰，还是不妨一读。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;基本常识&quot;&gt;基本常识&lt;/h2&gt;&lt;h3 id=&quot;1-位和字节&quot;&gt;1.位和字节&lt;/h3&gt;&lt;p&gt;说起编码，我们必须从最基础的说起，&lt;strong&gt;位和字节&lt;/strong&gt;(别觉得这个过于简单不值一说，我还真见过很多个不能区分这两者的程序员)。位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256（ 2^8 ）个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。&lt;/p&gt;
&lt;p&gt;而我们通常所讲的字符编码，就是指&lt;strong&gt;定义一套规则&lt;/strong&gt;，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;number&quot;&gt;01000001&lt;/span&gt;（&lt;span class=&quot;number&quot;&gt;0x41&lt;/span&gt;）&amp;lt;-&amp;gt; &lt;span class=&quot;number&quot;&gt;65&lt;/span&gt; &amp;lt;-&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即用字位序“01000001”来表示字母’A’。&lt;/p&gt;
&lt;h3 id=&quot;2-拉丁字符&quot;&gt;2.拉丁字符&lt;/h3&gt;&lt;p&gt;拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是&lt;strong&gt;基础拉丁字母&lt;/strong&gt;,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为&lt;strong&gt;基础拉丁字符&lt;/strong&gt;，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如’Á’)，形成了&lt;strong&gt;派生拉丁字母&lt;/strong&gt;，其表示的字符范围在各种语言有所不同，而&lt;strong&gt;完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集&lt;/strong&gt;。是比基础拉丁字符集大很多的一个集合。&lt;/p&gt;
&lt;h2 id=&quot;编码标准&quot;&gt;编码标准&lt;/h2&gt;&lt;p&gt;前文提到，字符编码是一套规则。既然是规则，就必须有标准。下面我就仔细说说常见的字符编码标准。&lt;/p&gt;
&lt;h3 id=&quot;1-拉丁编码&quot;&gt;1.拉丁编码&lt;/h3&gt;&lt;p&gt;ASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的&lt;strong&gt;ASCII编码也只支持基础拉丁字符&lt;/strong&gt;。ASCII的设计也很简单，&lt;strong&gt;用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’&lt;/strong&gt;。即表示字符含义的位数为7位，不难算出其可表达字符数为2^7 =128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应：&lt;/p&gt;
&lt;table&gt;&lt;br&gt;&lt;tr&gt;&lt;th&gt;字符类型&lt;/th&gt;&lt;th&gt;    字符&lt;/th&gt;&lt;th&gt;二进制  &lt;/th&gt;&lt;th&gt;    16进制&lt;/th&gt;&lt;th&gt;10进制&lt;/th&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;td&gt;可打印字符&lt;/td&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;    01000001&lt;/td&gt;&lt;td&gt;    0x41&lt;/td&gt;&lt;td&gt;65&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;td&gt;可打印字符&lt;/td&gt;&lt;td&gt;a&lt;/td&gt;&lt;td&gt;    01100001&lt;/td&gt;&lt;td&gt;    0x61&lt;/td&gt;&lt;td&gt;97&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;td&gt;控制字符&lt;/td&gt;&lt;td&gt;    \r&lt;/td&gt;&lt;td&gt;00001101&lt;/td&gt;&lt;td&gt;    0x0D&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;td&gt;控制字符&lt;/td&gt;&lt;td&gt;    \n&lt;/td&gt;&lt;td&gt;00001010&lt;/td&gt;&lt;td&gt;    0xA&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;/table&gt;

&lt;p&gt;前面说到了，ASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？&lt;/p&gt;
&lt;p&gt;当然，最简单的办法就是将美国人没有用到的&lt;strong&gt;第8位也用上&lt;/strong&gt;就好了，这样能表达的字符个数就达到了2^8 =256个，相比较原来，增长了一倍， 这个编码规则也常被称为&lt;strong&gt;EASCII&lt;/strong&gt;。EASCII基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了&lt;strong&gt;ISO 8859&lt;/strong&gt;,为解决256个字符不够用的问题，&lt;strong&gt;ISO 8859采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成&lt;/strong&gt;，分别称为ISO 8859-n(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如ISO 8859-1对应西欧语言，ISO 8859-2对应中欧语言等。其中大家所熟悉的&lt;strong&gt;Latin-1就是ISO 8859-1的别名,它表示整个西欧的字符集范围&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;需要注意的一点的是，ISO 8859-n与ASCII是兼容的，即其0000000(0x00)-01111111(0x7f)范围段与ASCII保持一致，而10000000（0x80）-11111111(0xFF)范围段被扩展用到不同的字符集。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-中文编码&quot;&gt;2.中文编码&lt;/h3&gt;&lt;p&gt;以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文GB2312（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，GB2312还是是用一个字节来表示以兼容ASCII）。我们用下表来说明各中文编码之间的规则和兼容性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/codes/cn_codes.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于中文编码，其规则实现上是很简单的，一般都是简单的&lt;strong&gt;字符查表&lt;/strong&gt;即可，重要的是要注意其相互之间的&lt;strong&gt;兼容性&lt;/strong&gt;问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。&lt;/p&gt;
&lt;h3 id=&quot;3-Unicode&quot;&gt;3.Unicode&lt;/h3&gt;&lt;p&gt;以上可以看到，针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，Unicode就是一种。为了能独立表示世界上所有的字符，Unicode采用&lt;strong&gt;4个字节表示一个字符&lt;/strong&gt;,这样理论上Unicode能表示的字符数就达到了2^31 = 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;微 &amp;lt;&lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;\u5fae&lt;/span&gt;   &amp;lt;&lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;01011111&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10101110&lt;/span&gt;
信 &amp;lt;&lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt;    &lt;span class=&quot;string&quot;&gt;\u4fe1&lt;/span&gt;     &amp;lt;&lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;01001111&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11100001&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0,这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？&lt;/p&gt;
&lt;p&gt;以上两个问题，困扰着Unicode，让Unicode的推广上一直面临着困难。直至UTF-8作为Unicode的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，&lt;strong&gt;UTF-8是Unicode的一种实现方式，而Unicode是一个统一标准规范，Unicode的实现方式除了UTF-8还有其它的，比如UTF-16等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;话说当初大牛Ben Thomson吃饭时，在一张餐巾纸上，设计出了UTF-8，然后回到房间，实现了第一版的UTF-8。关于UTF-8的基本规则，其实简单来说就两条（来自阮一峰老师的总结）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;规则1：对于单字节字符，字节的第一位为0，后7位为这个符号的Unicode码，所以对于拉丁字母，UTF-8与ASCII码是一致的。

规则2：对于&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;字节(&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;&amp;gt;1)的字符，第一个字节前&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;位都设为1，第&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;+1位为0，后面字节的前两位一律设为10，
剩下没有提及的位，全部为这个符号的Unicode编码。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/codes/utf8.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;举例来说，’微’的Unicode是’\u5fae’，二进制表示是”00000000 00000000 01011111 10101110“，其取值就位于’0000 0800-0000 FFFF’之间，所以其UTF-8编码为’&lt;strong&gt;111&lt;/strong&gt;00101 &lt;strong&gt;10&lt;/strong&gt;111110 &lt;strong&gt;10&lt;/strong&gt;101110’ （加粗部分为固定编码内容）。&lt;/p&gt;
&lt;p&gt;通过以上简单规则，UTF-8采取变字节的方式，解决了我们前文提到的关于Unicode的两大问题。同时，作为中文使用者需要注意的一点是&lt;strong&gt;Unicode(UTF-8)与GBK，GB2312这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换,如需转换，一般通过GBK查表的方式来进行&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;常见问题及解答&quot;&gt;常见问题及解答&lt;/h2&gt;&lt;h3 id=&quot;1-windows_Notepad中的编码ANSI保存选项，代表什么含义？&quot;&gt;1.windows Notepad中的编码ANSI保存选项，代表什么含义？&lt;/h3&gt;&lt;p&gt;ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，&lt;strong&gt;如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-什么是UTF-8的BOM？&quot;&gt;2.什么是UTF-8的BOM？&lt;/h3&gt;&lt;p&gt;BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的&lt;a href=&quot;http://sharecore.info/blog/2013/04/05/parse-csv-to-sql-for-insert/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;3-为什么数据库Latin1字符集（单字节）可以存储中文呢？&quot;&gt;3.为什么数据库Latin1字符集（单字节）可以存储中文呢？&lt;/h3&gt;&lt;p&gt;其实不管需要使用几个字节来表示一个字符，但最小的存储单位都是字节,所以，&lt;strong&gt;只要能保证传输和存储的字节顺序不会乱即可&lt;/strong&gt;。作为数据库，只是作为存储的使用的话，只要能保证存储的顺序与写入的顺序一致，然后再按相同的字节顺序读出即可，翻译成语义字符的任务交给应用程序。比如’微’的UTF-8编码是’0xE5 0xBE 0xAE’，那数据库也存储’0xE5 0xBE 0xAE’三个字节，其它应用按顺序从数据库读取，再按UTF-8编码进行展现。这当然是一个看似完美的方案，但是只要写入，存储，读取过程中岔出任何别的编码，都可能导致乱码。&lt;/p&gt;
&lt;h3 id=&quot;4-Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？&quot;&gt;4.Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/codes/mysql_var.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们分别解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;character_set_client&lt;/strong&gt;：客户端来源的数据使用的字符集，用于客户端显式告诉客户端所发送的语句中的的字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;character_set_connection&lt;/strong&gt;：连接层的字符编码，mysql一般用character_set_connection将客户端的字符转换为连接层表示的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;character_set_results&lt;/strong&gt;:查询结果从数据库读出后，将转换为character_set_results返回给前端。&lt;/p&gt;
&lt;p&gt;而我们常见的解决乱码问题的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;mysql_query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;SET NAMES GBK&#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其相当于将以上三个字符集统一全部设置为GBK，这三者一致时，一般就解决了乱码问题。&lt;/p&gt;
&lt;p&gt;character_set_database:当前选中数据库的默认字符集，如当create table时没有指定字符集，将默认选择该字符集。&lt;/p&gt;
&lt;p&gt;character_set_database已经character_set_system，一般用于数据库系统内部的一些字符编码，处理数据乱码问题时，我们基本可以忽略。&lt;/p&gt;
&lt;h3 id=&quot;5-什么情况下，表示信息丢失？&quot;&gt;5.什么情况下，表示信息丢失？&lt;/h3&gt;&lt;p&gt;对于mysql数据库，我们可以通过&lt;strong&gt;hex(colname)&lt;/strong&gt;函数（其它数据库也有类似的函数，一些文本文件编辑器也具有这个功能），查看实际存储的字节内容，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/codes/mysql_hex.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过查看存储的字节序，我们可以从根本上了解存储的内容是什么编码了。而当发现&lt;strong&gt;存储的内容全部是’3F’时，就表明存储的内容由于编码问题，信息已经丢失了，无法再找回&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;之所以出现这种信息丢失的情况，一般是将不能相互转换的字符集之间做了转换，比如我们在前文说到，UTF-8只能一个个字节地变成Latin-1，但是根本不能转换的，因为两者之间没有转换规则，Unicode的字符对应范围也根本不在Latin-1范围内，所以只能用’?(0x3F)’代替了。&lt;/p&gt;
&lt;h2 id=&quot;总结：&quot;&gt;总结：&lt;/h2&gt;&lt;p&gt;本文从基础知识与实际中碰到的问题上，解析了字符编码相关内容。而之所以要从头介绍字符编码的基础知识，是为了更好的从原理上了解与解决日常碰到的编码问题，只有从根本上了解了不同字符集的规则及其之间的关系与兼容性，才能更好的解决碰到的乱码问题，也能避免由于程序中不正确的编码转换导致的信息丢失问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;在面试的笔试题里出了一道开放性的题：请简述&lt;span class=&quot;keyword&quot;&gt;Unicode&lt;/span&gt;与UTF-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几
，确实挺失望的。所
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="技术常识" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>浅谈服务化架构</title>
    <link href="http://sharecore.net/2014/08/02/%E6%B5%85%E8%B0%88%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/"/>
    <id>http://sharecore.net/2014/08/02/浅谈服务化架构/</id>
    <published>2014-08-02T15:54:42.000Z</published>
    <updated>2015-03-22T08:14:55.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;这两年来，在服务化架构设计上的实践比较多，在此对关于服务化设计一些经验稍作总结，
知识经验水平有限，如有欠缺和不准确的地方，还请指出修正！     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我在&lt;a href=&quot;http://sharecore.net/2014/07/05/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《可扩展架构设计的三个维度》&lt;/a&gt;一文里，谈到服务化架构（SOA）在保证系统扩展性上，是一个比较好的架构设计实践。也谈到了通过服务网关的形式来进行多服务的注册与管理等。但困于篇幅，并未展开讲关于服务化架构实现层面上的具体细节。本文就结合我这两年来，在服务化架构设计上的一些实践经验，谈谈一个服务化框架其应该具备的一些功能以及其基本实现方式。&lt;/p&gt;
&lt;p&gt;这里说到的“服务”，本质上来说，就是指“RPC”。单纯的RPC功能实现，其实很简单，无非就是client发起调用，中间某个组件（甚至就是client本身）拦截调用信息，序列化后将信息传输到server端，server端收到调用请求后反序列化，根据请求详细发起实际调用后返回响应传输回给client端。这样的RPC很常见，比如常见的存储过程调用就是一例。但是在一个复杂的业务环境，如何管理和协同这些大量的RPC才是最麻烦的事情。所以，在此谈的“服务化”更多指的是对RPC的管理。&lt;/p&gt;
&lt;p&gt;一个复杂业务环境下的大量RPC究竟会遇到哪些问题呢？换句话说，一个服务化管理框架究竟应该具备哪些功能特性才算基本完备呢？以下是我的一些看法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.协议选型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为整个环境里的服务采用统一的数据序列化协议，其益处是显而易见的，能大大降低服务提供者和服务调用者之间的沟通成本，同时也可以为服务提供者减少应对不同数据协议需求而带来的代码复杂性。所以，在开始设计一个服务化框架时，第一件重要的事情就是选定一个标准的数据序列化协议。如何选择合适的序列化协议重点需要从&lt;strong&gt;扩展性，传输性能以及业界通用性（换句话说就是不同技术/语言的支持程度）&lt;/strong&gt;三个因素里来协调选择。当前看来，在这三个方面都做的比较好，也是使用最广泛的就是&lt;strong&gt;Json&lt;/strong&gt;和&lt;strong&gt;Protobuf&lt;/strong&gt;了，基于文本的Json在可读性和灵活性上占优，而基于二进制的Protobuf在传输性能生更胜一筹。而如果整个环境开发的技术栈比较统一，比如全是Java/.NET，也可以选择对这一技术更加友好的序列化协议。我这一次选择的就是Json，因为从面对的业务情况来看，传输性能不是根本矛盾，而灵活性要求较高，同时服务使用者使用的技术也较为多样化。&lt;/p&gt;
&lt;p&gt;在序列化协议的选定上&lt;strong&gt;要避免的一个误区就是采用自定义协议而不是业界通用协议&lt;/strong&gt;,自定义协议将很容易面临扩展性和使用推广方面的问题，同时，当有新的开发人员加入进来，其需要花费时间来学习与了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通讯协议选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通讯协议上的选择上灵活性比较大，有多种选择，可以在基于HTTP或TCP链接上建立自己的通讯协议。比如可以设计一个简单的header（定长）+body（序列化的请求/响应）。如果采取json作序列化协议的情况下，可以跟我本次的选择一样，采取一个类似&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON-RPC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;json-rpc&lt;/a&gt;, 完全基于json的通讯协议：&lt;/p&gt;
&lt;p&gt;Resust:&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;&lt;span class=&quot;attribute&quot;&gt;ActionName&lt;/span&gt;&quot;:&lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;Do&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;&lt;span class=&quot;attribute&quot;&gt;AppId&lt;/span&gt;&quot;:&lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;xxxxxx&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;&lt;span class=&quot;attribute&quot;&gt;RequestContent&lt;/span&gt;&quot;:&lt;span class=&quot;value&quot;&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Response:&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	“RequestId”:“xxxxxxxxx”，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	“HasError”:false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;ResponseContent&quot;:&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于服务访问对象主要为企业内部的情况，不太建议采取与http完全绑定的restful协议，这将牺牲链接层选择的灵活性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.注册与授权管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册管理是解决系统交互复杂性的必备良药，我建议超过三个系统之间的系统交互，都应该具备注册管理功能。对于服务化架构来说，注册管理也是最为核心的一项功能。当服务数量和服务使用者数量爆发性增长时，最难回答的问题就是“服务被谁使用了？”以及“有哪些服务可供使用？”，注册管理就是解决这两个问题的最佳方式与实践。 &lt;/p&gt;
&lt;p&gt;注册管理的实现上其实也很简单，提供一个Config Server（配置中心），收集服务提供者的注册信息（包括服务名称，服务地址（可以多个），版本，超时时间控制等），我们称为&lt;strong&gt;服务的元信息&lt;/strong&gt;。而当服务使用者需要调用相应的服务时，就可以利用这些元信息来查找和调用相应的服务了。&lt;/p&gt;
&lt;p&gt;不过，在元信息的使用上，存在两者架构方式&lt;/p&gt;
&lt;p&gt;1.服务使用者访问统一的服务中转器，由服务中转器按照注册信息以及负载情况将请求转发到相应的服务地址上。服务执行后，响应信息返回到服务中心，服务中心将响应回送给调用方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa/service_2.png&quot; alt=&quot;service_2&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式的优点是能比较好的控制所有请求的调度。当服务元信息发生变化时，能及时地调整请求转发（负载）与超时控制等。缺点是请求和响应均需要由中转中心负责转发，性能耗费较大。同时，中转中心的可用性也容易产生问题，必须通过集群的方式来解决。&lt;/p&gt;
&lt;p&gt;2.服务使用者负责从配置中心获取服务地址等信息，然后有由服务使用者直接向相对应地址上的服务发送请求，请求也直接由服务提供者返回给服务调用者。同时，服务使用者本身可以缓存一定的服务元信息，防止每次访问都要从配置中心获取，以降低配置中心的负载，增强整个系统的可用性。当配置中心的服务元信息发生变化时，通过通知的方式告知服务使用者更新本地缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa/service_1.png&quot; alt=&quot;service_1&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种架构方式与第一种架构相比，能显著降低性能的损耗，以及服务使用者对中心节点的直接依赖。但代价是需要彻底改造服务使用者的调用方式，框架的代码必须侵入到客户端的开发中去。一般会针对不同的客户端提供clientLib，但当客户端实现方式多样化时，这种代价是非常大的。&lt;/p&gt;
&lt;p&gt;由于我这次面对的客户端多样性，客户端开发也不在控制范围内，所以选择就是第一种方式。&lt;/p&gt;
&lt;p&gt;关于授权，可以与注册管理相互结合，将授权信息同一保存到配置中心。对于企业内部访问的服务，做到通过IP+AppId授权应该就够了。这里有个经验是可以将授权和服务版本确认两者结合起来，即在&lt;strong&gt;授权的同时完成服务版本的确定&lt;/strong&gt;，而不采取由客户端发起访问时指定版本的方式，这样做的好处是框架和服务提供者对于服务版本变更和灰度发布具有更高的可控制性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.路由与过载保护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://sharecore.net/blog/2014/07/05/ke-kuo-zhan-jia-gou-de-san-ge-wei-du/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《可扩展架构设计的三个维度》&lt;/a&gt;一文里谈到通过单元化架构以满足Z轴扩展，以满足差异性的需求或者做到安全隔离。而&lt;strong&gt;服务路由是实现这种单元化架构的基本保障&lt;/strong&gt;，以保证能将来自不同访问者请求或者不同的请求内容，分发到不同的服务提供区域去，形成单元化架构的闭环。当然，路由功能并不一定需要框架来独立实现，业界许多通用的（软）负载均衡器可以协助实现，如Nginx/HAProxy/LVS这些。但是这类通用的负载均衡软件的问题是路由算法比较通用，当需要扩展到与业务逻辑相关的路由绑定时，比较麻烦，比如需要用户ID按权重分配路由。在此建议，&lt;strong&gt;可以采取通用的负载均衡软件当第一层接入，而在服务节点之间采取自己实现路由模块的方式。&lt;/strong&gt;而在实现路由模块时，需要将扩展性上的考虑放在第一位。 &lt;/p&gt;
&lt;p&gt;对于服务化架构，保障提供服务提供者的业务系统不受“恶意”调用或突发性激增调用的破坏，过载保护功能至关重要，它能起到系统“保险丝”的效果。前文提到可用于接入的Nginx/HAProxy/LVS这些软件，也多少提供了过载保护的功能。如果自己实现过载保护模块，具体可参见我的&lt;a href=&quot;http://sharecore.net/blog/2014/06/21/guo-zai-bao-hu-suan-fa-qian-xi/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《过载保护算法浅析》&lt;/a&gt;一文。对于过载保护的一个经验是：&lt;strong&gt;过载保护越靠近服务访问前端越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.服务拆分与组合化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统的SOA概念，指的是不同的应用系统之间相互通过大粒度服务的方式进行集成。而当今的服务化架构已经摆脱了这一概念的束缚，更多讲的是系统内部模块级甚至是功能级的服务化模式。也就是说服务实现的粒度更小了。这当然为应用和服务的实现带来了更强的灵活性，服务交付周期也大大缩短了。但这样的细粒度拆分服务，带来的问题是项功能的实现需要访问的服务数量成倍的增加。如下图所示：一个客户下订单的功能实现需要分别访问：客户信息服务，产品类别服务，库存服务，订单管理服务等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa/service_3.png&quot; alt=&quot;service_3&quot;&gt;&lt;/p&gt;
&lt;p&gt;这将显著增加功能实现的复杂性。为了解决这一问题，我们只能再次使用那条永远有效的“中间层定律”：&lt;strong&gt;任何计算机问题都可以通过中间加一层来解决。&lt;/strong&gt; 我们可以将相应的服务组合成一个新的服务提供出去，比如上面的例子，我们可以按以下方式组合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa/service_4.png&quot; alt=&quot;service_4&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.基于配置的服务运行时提供&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前文已经概述了一个服务化框架应该具有的一些基本功能以及一些基本的架构实现方式。但这个服务框架究竟如何与业务开发相结合呢？也就是说业务逻辑代码与框架代码之间如何隔离,而不是让框架的功能代码侵入到业务逻辑代码的开发中来?这里通用的做法就是&lt;strong&gt;通过基于配置，由框架提供运行时，动态加载业务代码的方式&lt;/strong&gt;。做到这点，只需要约束业务逻辑代码实现相应的接口/基类，然后打包成相应的组件（如jar/dll/so等）提供给框架加载运行即可，类似于java servlet的开发，业务开发完全不用关心服务化框架任何功能，专注开发业务逻辑即可。同时，对于既有代码的服务化也将变得简单，只需要稍加重构封装出实现相应的接口即可。&lt;/p&gt;
&lt;p&gt;配置类似于：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;serviceName&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;Customer.GetCustomer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;imp&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.customer.getCustomer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt;&amp;gt;&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;service&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时，这种基于组件配置的服务实现，对于组合组件实现服务也非常简单。只需要将上面的配置改为嵌套的方式既可以实现组合。比如对于订单生成服务只要组合如下：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;serviceName&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;Order.CreateOrder&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;imp&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.inventory.checkInventory&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;imp&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.order.createOrder&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;imp&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.inventory.updateInventory&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;biz&lt;/span&gt;&amp;gt;&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;service&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本来看，服务化架构已经在业界完成了落地，尤其是互联网公司，更是基于这一架构的领先者，有许多经验值得借鉴。当然，这个落地的服务化架构，与当年被各大商业公司用WS-*和ESB玩坏的SOA概念相去甚远。也再一次证明，那些被鼓吹出来的技术概念，只有当那些商业公司不再炒作之时，方是其真正落地之日（SOA如此，当今热炒的“大数据”，“云计算”这些概念又何尝不会是如此呢？）。在技术被鼓吹得风头正劲时，千万要保持冷静，别被那些商业公司所忽悠,你完全可以自己实现更轻量级更具有扩展性的架构。不信的话，可以去问问，那些当年花大价钱去买SOA商业组件的公司，他们还好吗？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这两年来，在服务化架构设计上的实践比较多，在此对关于服务化设计一些经验稍作总结，
知识经验水平有限，如有欠缺和不准确的地方，还请指出修正！     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我在&lt;a href=&quot;http://sharecore.net/2014/0
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="服务化" scheme="http://sharecore.net/tags/%E6%9C%8D%E5%8A%A1%E5%8C%96/"/>
    
      <category term="架构" scheme="http://sharecore.net/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面对喷子明哲保身</title>
    <link href="http://sharecore.net/2014/07/27/%E9%9D%A2%E5%AF%B9%E5%96%B7%E5%AD%90%E6%98%8E%E5%93%B2%E4%BF%9D%E8%BA%AB/"/>
    <id>http://sharecore.net/2014/07/27/面对喷子明哲保身/</id>
    <published>2014-07-27T15:57:23.000Z</published>
    <updated>2015-03-16T16:29:07.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;本打算本周继续写关于技术的话题，但是今天碰到一件闲事，让我改了想法！我得写一篇“教化”的文字，你们暂且读读，个人牢骚，慎重评论！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先从今天这件“闲事”说起：&lt;/p&gt;
&lt;p&gt;最近，我在玩一个群聊App，可以让附近的人加入到同一感兴趣的话题的群里，一起聊想法和观点！我建了一个叫“哲学家”的群，写了句介绍大概意思是说“这里不欢迎思考懒惰者”。本来是无意之举，没想到，还真吸引了小小几十个人的加入。我懒得打理，群里也一向平静如常。而今天，一人在群里发了一个很大的话题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你们对王阳明的心学怎么看？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这话题大的根本无从聊起，而我又觉得难得有人发起讨论，不想因为话题太大无从讨论而冷掉，于是准备将话题缩小到王阳明的“知行合一”的观点上来。于是隐晦的回复了一个类比：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;妓女可以谈贞操，因为是过来人，能懂得有和没有的区别;而处女不能谈性技，处女啥都不会，谈什么性技，她连谈贞操的资格也没有！
——喷下“理学”而已，别戴帽子！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我本以为，问问题者如果懂得王阳明的知行合一学说，懂得其对程朱理学者“灭人欲”的批判的话，应该能看懂我回答此话的类比之意！而没想到，可能是我回答的太晦涩，还是类比的太悬浮，其给出的回话完全出于我所料，其答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;群主真是好牛逼啊，从贞操谈到性技谈到理学？敢问何为理学？理学和性技有何相关？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种断章取义的回应真是“如雷贯耳”，也似曾熟悉，网络上到处充斥着这种牛头不对马嘴的讨论！我一时无法答上话！沉默良久后，我回答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一，你问的王阳明，所以我将王阳明的知行合一说作个类比，表示我赞成它关于知行合一的学说以及其对程朱理学的虚伪理论的批判;

第二，贞操和性技之事，是程朱理学最为避讳而自己却无法做到之事，用其“讽”理学，并无不妥！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而后，又有另外一个人回答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;读过几本破书，就敢对理学大放厥词，装什么逼啊！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到这样的回答，我嘴里的水直接喷了出来，这么快就人身攻击了，完全出乎我意料！我赶紧停止了讨论！&lt;/p&gt;
&lt;p&gt;闲事至此，我悲从中来，这些人的嘴脸如此熟悉！在国内的网络上，总有一大群人，根本不理解提出观点者其本身的意思，就&lt;strong&gt;断章取义对观点提出者，以其当时心情为标杆，随意对观点提出者进行毫无原则的人身攻击&lt;/strong&gt;。他们不知道，说出的每句话背后是需要深刻思考的，他们的头脑或许根本不能支持其去思考！他们只是需要一个情绪排泄的通道，就像排泄物在肚子里需要排出来一样，他们脑子里的排泄物也必须要排出来。&lt;/p&gt;
&lt;p&gt;要进行一场正常的观点交碰，是如此的困难！任何观点，只要稍微“左一点”或“右一点”，哪怕是完全的”中立“观点，必将有人以一副“你敢再说？老子弄死你”的流氓嘴脸出现！他们不去思考给出的观点的本质是什么，或者其根本就不具有辨识观点本质的认知能力，可他们有着满腔“鸡血”，非让你进入”地狱“永不翻身才满意！&lt;strong&gt;他们可以满嘴的”自由“，但是他们不能给你发表观点的”自由“;他们可以满怀”善良与人性“，却可以将你全家老小问候一个遍&lt;/strong&gt;。对于这类人，我们已经不能称其为”愤青“了，因为”愤青“们反的只是保守言行，而这类人，不管左中右，逮着就喷，无观念，无廉耻，无底线地！用网络上的名词，暂且称其为”喷子“。&lt;/p&gt;
&lt;p&gt;我想，如果杀人不犯法的话，他们肯定把你找出来立马弄死！在这样的一个环境里，你需要吃了雄心豹子胆才敢”挑事“，没那承受力的话，就最好明哲保身少说话，或者与这群人为伍，让”伟大的群体“给予你安全保护。为了安宁的生存，你就得放弃你的自由。这就好像鲁迅先生的形象描述：&lt;strong&gt;既然猴子可以变人，为什么现在的猴子不想变人呢？并非都不想变人，也有少数猴子想变人，它们曾经两条腿站起来，学人走路并且说它们想做人。然而它们的同类不允许，说它违背了猴子的本性，把它们咬死了！&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有时候，我还想左一点的认为，咱们就别搞义务教育了！让那么多喷子学会的文字，却只能被他们用来行这些对社会进步有害而无益之事，到底有何意义呢？还不如让这些人根本不识字不会写字，他们就没法喷了！我甚至违心的去认为，”洗脑”是对的，因为&lt;strong&gt;对于满脑子都是排泄物的人，洗脑或许有益健康&lt;/strong&gt;，至少能让他们有原则的守护其观点吧！但回头想想，这样或许是违背子自由教育或自由意志的，我不能这样持双重观点，否则，我不也跟”喷子“无异了吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人立身？以为何？我想最起码就是独立思考之能力以及统一与一致的价值观！&lt;/strong&gt;而这些”喷子“们，最为缺少的就是这两项基本的素质！这两项素质的缺乏，是无药可治的！因为能治其病的前提，是其必须先具有两项素质，这就成了一个”蛋生鸡鸡生蛋“的问题，不会有治疗方案了。所以，在此，对于这个现象，除了牢骚，我给不出任何根治良方！或许像我这样，碰到这类人，乖乖的躲起来，以免他们的排泄物脏到自己！听之任之，任其放肆与疯狂,就暂且是最好的办法了！&lt;/p&gt;
&lt;p&gt;这真是一个悲剧，意味着我们不会再有一个安宁之日了！明哲保身吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;本打算本周继续写关于技术的话题，但是今天碰到一件闲事，让我改了想法！我得写一篇“教化”的文字，你们暂且读读，个人牢骚，慎重评论！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先从今天这件“闲事”说起：&lt;/p&gt;
&lt;p&gt;最近，我在玩一个群聊App，可以让附近的人加入到同一感
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>技术的进化</title>
    <link href="http://sharecore.net/2014/07/20/%E6%8A%80%E6%9C%AF%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
    <id>http://sharecore.net/2014/07/20/技术的进化/</id>
    <published>2014-07-20T15:58:29.000Z</published>
    <updated>2015-03-16T16:29:05.000Z</updated>
    
    <content type="html">&lt;p&gt;前几日，吴军博士在微博上转发了王石为其新书《文明之光》写的序言。在序言里，王石提到了达尔文进化论在社会与技术的适应性问题。王石在他短短几句话里并未充分说明了他的观点，只是举了英文键盘的例子说明了&lt;strong&gt;存活下来的不一定更“好”，仅仅是更“适”而已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我在微博上留下了一条评论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生物突变过程，并不一定是适合文明尤其是技术的进化的，好比如从帆船不可能突变到轮船，喷气机也不是内燃机或其它任何先前技术的变种，技术的进化更多是组合进化不太具有偶然性，而不是生物的单物种偶然性突变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用达尔文的理论去解释不同领域的演进,是许多人的偏好，尤其是国人。但是，无论觉得达尔文理论能如何为你切身地解答从哪而来的问题，将它放置于任何领域成为“大一统”的进化观点，我想是不合适的，至少将其置于技术的领域，是不完整的。尽管吴军博士回复说，《文明之光》一书并没有太谈进化论，我还是想把我的观点讲清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.不完整的进化论理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;达尔文的生物进化理论需要从两个方面来理解：&lt;strong&gt;变异与选择&lt;/strong&gt;。由于某些历史与政治的原因，进化论被引进进入中国时，就被严复梁启超他们“阉割”了，只片面的强调了“选择”一含义，这也就是大多数人固有的“物竞天择，适者生存”的观点，而对其“变异”层面的含义却知之甚少。由于“进化就是选择”这一狭隘观点的影响，导致达尔文的理论被”泛滥“地解释所有的领域的发展，因为单从“选择”层面来看，其确实是适合其它领域的。当然，用来解释社会发展领域的发展，也是当初严复和梁启超他们原本目的。&lt;/p&gt;
&lt;p&gt;如果说“进化就是选择”，那前面王石先生举的英文键盘一例来说进化，也是合理的（其实这也就是常说的”路径依赖“）。但是这样的观点如果奉成为“理论”，肯定是不完整的。选择论回答不了被选择的“物件”从何而来的疑问。而完整的达尔文理论认为&lt;strong&gt;变异为选择提供了资源&lt;/strong&gt;。如果说”选择“解答了发展的问题，那”变异“则解答了起源的问题。在生物的进化上，这里的变异指的就是基因突变，并且是单个物种内的自身基因变化。&lt;/p&gt;
&lt;p&gt;正是这种关乎基因突变的观点，将达尔文理论套到技术领域，是根本站不住脚的。比如雷达诞生于半导体，你可以对20世纪30年代的半导体线圈进行任何你喜欢的改变，但是你永远不可能得到雷达，制造雷达需要一个和半导体完全不同的理念。我前文微博里提到的帆船到轮船，喷气机到内燃机的也同样如此，无论你对帆船如何改造，没有革命性发动机出现，你不可能得到轮船，而发动机的出现，跟”船“这个”物种“不存在任何关系。而从喷气机到内燃机，也不是一脉的向前突变得到的，而是依赖完全不同的物理理论的出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.技术进化的特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么技术领域的究竟如何向前进化的呢？技术作家布莱恩.阿瑟在其《技术的本质》一书里给出了一个初步的答案。布莱恩.阿瑟认为技术的进化具有以下两大特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合进化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技术总是由一些基本的功能模块组合而成的&lt;/strong&gt;。技术的组合进化，是技术演变的最本质特征，也是其不同与生物进化的根本区别。&lt;/p&gt;
&lt;p&gt;在人类发展最初的石器时代，石制工具就被打磨成两类，锋利的和有孔的，这两类又与木制的手柄组合成复合工具，锋利的成了矛，有孔的成了锤头。回到现代，你打开一台老式的台式电脑，你会发现里面的零部件，如CPU，硬盘，内存条等。同时拆开一台现代的智能手机，也会发生同样的部件。同样，蒸汽机的出现，其与原来的帆船技术的组合，从而使得轮船得以出现服务于人类。&lt;strong&gt;技术在某种程度上一定是来自此前已有技术的新的组合&lt;/strong&gt;，这是新技术出现的根本特征，也解答了进化论中关于”变异“那一部分问题。而这个组合进化产生变异的特征在生物体上是看不到的，生物的变异是指单个生物体的基因突变，而不同物种相互组合杂交而进化，几乎没出现过。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;具有层级递归性模块化演进&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术是组合进化的，但是其不是单纯的一层组合，也就是说不是将具有匹配的概念或原理的目的单层次的聚集起来，即可得到新的技术。其组合具有层次结构。可以将技术分解成主集成，次级集成，次次级集成等，直至分解为最基本的部分。如果说整体的技术是树干的话，那次级集成是枝条，最基本的零件就是更小的分支了。以一本纸质书为例，其主集成是纸张和印刷的组合，而纸张和印刷两者可以继续拆分，如印刷可以拆分为油墨技术，电子技术等等。&lt;strong&gt;技术呈现出这种递归性的结构，技术总是包含着技术，直到最基础的水平&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果只是将技术的单元进行层次化的组合，那将是一个无比复杂的工程。比如一个手表有1000个零件，一个钟表匠一个零件一个零件地安装，安装过程中，如果他的工作被打断了，他就必须从头开始。但是，如果将10个模块组装起来，每个模块又由10个子模块组装起来，每个子模块由10个零件组合起来，当他暂停或被打断工作时，他只是损失了一小部分工作。这种零件集成可以更好地预防不可预知的变动，且更易修复。同时，除了解决复杂性的带来的低效问题，模块化更为重要的一点是允许技术的组成部分分别演进，从而又再推动整体技术的前进。好比如发动机的这一模块的进步，可以推动汽车，轮船这些整体技术的进步一样。&lt;/p&gt;
&lt;p&gt;当然，将技术分割为功能模块是需要付出一些代价的，比如需要耗费时间和精力定义模块之间的标准等。所以，&lt;strong&gt;只有模块能被反复使用，且反复使用的次数足够时，才值得付出代价将技术进行分割&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.技术进化的启示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面关于技术进化的特点的讨论，不只是让我们认识了技术进化的与生物进化的区别，更是能更好的指导我们构建更有生命力能向前进化的技术产品。回到我们熟悉的软件系统领域，我们见过太多技术产品被很快淘汰，也见过很多技术产品永远处于不断推倒后重构的死胡同里。从进化的角度看，这样的技术产品根本不存在进化的可能。这其中根本原因，我想更多是其没有满足我们前文说到的可进化技术的一些基本特点。一个没有组合特点的系统，其必然扩展性差，必然面临无法向前进一步进化的可能。而没有定义层次和规则，那也就没有模块化的概念，系统无法进行单个模块的垂直演进，没有模块级别的重用， 当碰到任何不可预知的变动，必然是全部推倒重新再来。这样的系统产品，当然也就不存在生命力可言。&lt;/p&gt;
&lt;p&gt;对此审视我们用过的系统产品，那些经久不衰的，如Unix/Linux，必然是遵循这技术进化的根本特征的。而对于当今互联网产品而言，生命力确实是一个奢侈的词，这应该不仅仅是生态环境的选择问题,而需要系统产品生产者更多的反思！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前几日，吴军博士在微博上转发了王石为其新书《文明之光》写的序言。在序言里，王石提到了达尔文进化论在社会与技术的适应性问题。王石在他短短几句话里并未充分说明了他的观点，只是举了英文键盘的例子说明了&lt;strong&gt;存活下来的不一定更“好”，仅仅是更“适”而已&lt;/strong&gt;。
    
    </summary>
    
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>不确定性与马尔科夫链</title>
    <link href="http://sharecore.net/2014/07/13/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%8E%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/"/>
    <id>http://sharecore.net/2014/07/13/不确定性与马尔科夫链/</id>
    <published>2014-07-13T15:59:25.000Z</published>
    <updated>2015-03-16T16:27:31.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;这个月玩公司的世界杯竞猜游戏，期间经历了各种跌宕起伏，有过竞猜游戏币被清零的记录（后来贷款翻身），也有过“一夜暴富”荣登榜首的时候（多亏了乌拉圭人和巴西人），到现在理论上还保留着拿最后冠军的希望。游戏期间无数次想到了关于“不确定性”的理论，结合以前读书的一些所获，如是有了今天的文字。&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;一-不确定性&quot;&gt;一.不确定性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 不确定性含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓不确定性，是指超越人类理性驾驭而无法预测的事情。我们生活充满了不确定性。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;深圳下半年的房价是会上涨还是下跌？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某互联网公司明年的股票走势如何？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;人类的的所有家务劳动，在未来一百年内会不会可以被机器人取代呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于不确定性，其实有两个层面的含义，&lt;strong&gt;第一层理解是事物本身不能确定;第二层理解是事物本身是确定的，只是人类无法预知，或者预知要花费的成本不是人类有生之年可以承受的&lt;/strong&gt;。这两层含义，暂时是无法被证实或证伪的。这就好比如无法证明上帝是否存在一样，但是基督教通过“信仰”来解决，他们告诉你：上帝是存在的，你希望他在他就在，你信他在他就在。&lt;/p&gt;
&lt;p&gt;人类对于不确定性有着天生的恐惧，生活在不确定性的世界里的人没有安全感。人类诞生之日起就开始了寻找真理之路。为什么要寻找真理呢？无非就是为自身提供一种安全感。在一个不确定性的世界里，人类不知道自己下一秒自己的命运或财富会不会颠覆，甚至连生命也没法得到保证，所以才会愿意牺牲部分个体活动的自由，集结成群，甚至是让少数人凌驾于自身之上，组织成政府，以取得安全感与保护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 不确定性的根源解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于不确定性的根源，哲学与科学上已知的解释有两个：&lt;strong&gt;非线性与不确定性原理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非线性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的线性思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只要每天多比别人工作2小时，就能产生好的绩效，拿更多的奖金&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只要赚到足够的钱，买房买车，心爱的妹子就会嫁给你&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经济危机时，只要多发货币就能刺激经济增长（凯恩斯主义）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某公司因为抄袭所以获得了成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种简单的“只要…就…”，“因为…所以…“，就是典型的线性逻辑，也是人类大脑天生的默认工作模式，也被称为是一种”思考懒惰“。可是，事物的状态的确定并不是单纯的线性逻辑。多工作两小时，如果工作方向不对，工作方式效率低下，同时身体的精力也是有限，无法长期坚持长时间的工作，能不能产生好的绩效是不确定的;赚到足够的钱，但同时不能忘了，还有很多人跟你一样赚钱买房买车，甚至比你赚的更多，妹子的选择也就更多，最后嫁给你还是嫁给别人也是不确定的。凯恩斯主义就更不用说了，几年前的4万亿产生的后果，你我不都正在尝着吗？某公司抄袭，可是跟它一样抄袭的公司多了去了，最后都剩下的却寥寥无几。&lt;/p&gt;
&lt;p&gt;事物的发展按照的是非线性逻辑，决定了事物具有”不确定性“的天然属性。事物初始条件的细微变化都可能引起事物发展方向的极大扭转，以致我们无法预料。如蝴蝶效应，墨菲定律说的就是这个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不确定性原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不确定性原理&lt;/strong&gt;是量子物理学上的一个概念，它表明&lt;strong&gt;粒子的位置和动量不可同时被确定&lt;/strong&gt;。由德国的量子力学奠基人之一维尔纳·海森堡提出，也称为”海森堡不确定性原理“。&lt;strong&gt;不确定性原理从量子层面解释了不确定性是物质的固有属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通常情况下，不确定性原理易与为大家所熟悉的”&lt;strong&gt;观察者效应&lt;/strong&gt;“所混淆，观察者效应是指被观察的现象会因为观察行为本身而受到一定程度或者很大程度的影响，也就是说由于事物被观察了，从而导致了它的行为路径发生变化。但这两者是不同的，观察者效应强调的是观察本身对事物的发展所产生的影响，而海森堡不确定性原理强调的是事物本身所具有的属性，跟观察本身无关,这点是需要注意的。&lt;/p&gt;
&lt;p&gt;前文说到人类对于不确定性有着天生的恐惧，而事物本身具有不确定的天然属性，这里存在着矛盾。而这种矛盾，正是&lt;strong&gt;激励人类不断向前追求真理的最大动力&lt;/strong&gt;。但不管追求真理之路向前走多远，对确定性的知识掌握总是有限，同时，对于一个个体来讲，由于精力和智力所限，能掌握的确定性知识也更为有限。以至于完全靠真理和知识来克服对不确定性的恐惧，是不现实的。为了在真理和知识缺乏的情况下作出准确（或合适）的决策判断，人类学会了&lt;strong&gt;概率思考&lt;/strong&gt;，即从事物的历史发展轨迹中统计分析将来的发展方向。建立了较为完善的数理分析理论，比如提出常见中心极限定理、正态分布、二项式分布等基础的统计知识理论。&lt;/p&gt;
&lt;p&gt;在读吴军的《数学之美》一书，对于其中提到的&lt;strong&gt;马尔科夫链&lt;/strong&gt;预测模型印象颇为深刻。马尔科夫链就是一个非常简单的概率思考模型。&lt;/p&gt;
&lt;h2 id=&quot;二-马尔科夫链&quot;&gt;二.马尔科夫链&lt;/h2&gt;&lt;p&gt;前文说到，随着时间的发展，事物所呈现的状态是不确定的，也可以称为是随机的。比如我们可以将&lt;em&gt;s1,s2,s3….st,…&lt;/em&gt;看成是这一个月来深圳每天的最高气温，这里的每个&lt;em&gt;st&lt;/em&gt;都是随机的。同时，事物的每个状态可能与它周围其它的状态相关，比如这一个月每天的最高气温，可能与深圳前段时间的最高气温相关。如果要把每个决定因素考虑进来，将会无比复杂，超出认知预测的范围。为此，俄罗斯数学家安德烈·马尔可夫提出简化的假设：&lt;strong&gt;假设事物每个状态，只与它的前一状态相关,而不考虑历史其它状态&lt;/strong&gt;。比如，我们预测明天的气温，只考虑今天气温，而硬性规定不考虑前天的气温情况。由于，这种状态转换的呈现出链表的形式，所以也称为&lt;strong&gt;马尔科夫链&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;日常生活中，有很多事情可以用马尔科夫假设来简化的。比如在我们行走时，我们的下一位置，一般只与我们当前的位置（假设为5）有关，我们向前一步，位置就+1（即为6）,向后一步位置就-1（即为4），这个下一位置与我们当前位置之前的位置（1,2,3,4）没有关系，可以忽略。当然，并不是每个事物都满足马尔科夫假设，比如彩票。&lt;/p&gt;
&lt;p&gt;而将&lt;strong&gt;马尔科夫假设与事物状态转换概率结合来&lt;/strong&gt;就可以建立一个简单的预测模型。我们以天气预测的例子来说明:&lt;/p&gt;
&lt;p&gt;根据日常经验，我们看到当前的天气状态是多云时，天气的下一个状态可能会是下雨;而当雨水开始消退，云也减少时，接下来可能就是天晴了。我们收集某个地区十年内的天气数据，计算出每种天气（暂时限制为三种：多云，晴天，雨天）之间相互转化的概率，统计结果如下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/markov_table.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上转换表可以用&lt;strong&gt;状态机&lt;/strong&gt;来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/markov_list.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;也可以用&lt;strong&gt;状态转换矩阵M&lt;/strong&gt;来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/markov_matrix.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;有了状态转换矩阵，通过基本的矩阵运算，就可以对下一天气状态进行预测了。假设当前状态是多云，即100%确认当前天气为多云，可以用&lt;strong&gt;向量V&lt;/strong&gt;来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/markov_vector.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;对下一状态的预测可以通过以下运算求得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下一状态S2 = V&amp;times;M = [(1 &amp;times;0.1 + 0&amp;times;0.3 + 0&amp;times;0.4); (1&amp;times;0.5 + 0&amp;times;0.6 + 0&amp;times;0.1); (1&amp;times;0.4 + 0&amp;times;0.1 + 0&amp;times;0.5)]&lt;br&gt;= [0.1; 0.5; 0.4];*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即可得下一状态多云的概率为0.1,雨天的概率为0.5,晴天的概率为0.4，雨天的可能性最大&lt;/p&gt;
&lt;p&gt;继续计算下一状态S3&lt;/p&gt;
&lt;p&gt;&lt;em&gt;S3 = S2&amp;times;M =[(0.1&amp;times;0.1 + 0.5&amp;times;0.3 + 0.4&amp;times;0.4); (0.1&amp;times;0.5 + 0.5&amp;times;0.6 + 0.4&amp;times;0.1); (0.1&amp;times;0.4 + 0.5&amp;times;0.1 + 0.4&amp;times;0.5)]&lt;br&gt;= [0.32; 0.39; 0.29];&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不出意料，雨天的可能性还是最大。无论再计算多少步，结果都会是雨天的可能性最大。这是为什么呢？是因为状态转换表只保存了最后的一个状态的信息，所有的状态转换只与最后一个状态信息相关，所以，接下来的状态也就逃脱不出初始状态的约束了。这种只考虑最后一个状态信息的马尔科夫链称为&lt;strong&gt;1阶马尔科夫链&lt;/strong&gt;。那如如果要提高准确性，使得下一状态不只是受上一状态的约束，该怎么做呢？可能你已经想到了，提升到&lt;strong&gt;多阶马尔科夫链*&lt;/strong&gt;即可。比如2阶马尔科夫链的转换概率表可以用如下的表格来表示（只画出了1/3部分，其它部分依次类推，共会有18种组合）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/markov_table_2.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上2阶状态转换表，表明了下一天气状态是由最后两天的天气决定，由它计算出来的结果准确性会比1阶的矩阵计算结果要高，随着阶数的继续递增，准确性也会相应的提高。可是这个提高是有代价的，阶数越高，计算的复杂性也就越大，而且是呈指数级的增长而&lt;strong&gt;非线性&lt;/strong&gt;的增长。当阶数增大一定程度，计算的复杂度超过人类现有的计算能力范围后，问题也就变成了&lt;strong&gt;不确定性问题&lt;/strong&gt;了。&lt;/p&gt;
&lt;h2 id=&quot;总结：&quot;&gt;总结：&lt;/h2&gt;&lt;p&gt;世界万物具有本质的不确定性，人类由于对不确定性的恐惧而选择追逐真理。但是，完全靠真理来克服对不确定性的恐惧是不现实的，有时候我们需要学会接受不确定性，并通过概率思考来来对不确定性作出决策判断。马尔科夫链模型就是一个非常简单的概率决策模型，是很好的概率思考实践。&lt;/p&gt;
&lt;p&gt;最后PS一条：如果你没法掌握足够的股票市场一手信息，遵循“买涨不买跌”的原则进行股票交易的话，会比你无意义的各种推测要好的多！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;这个月玩公司的世界杯竞猜游戏，期间经历了各种跌宕起伏，有过竞猜游戏币被清零的记录（后来贷款翻身），也有过“一夜暴富”荣登榜首的时候（多亏了乌拉圭人和巴西人），到现在理论上还保留着拿最后冠军的希望。游
    
    </summary>
    
    
      <category term="复杂性" scheme="http://sharecore.net/tags/%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>可扩展架构设计的三个维度</title>
    <link href="http://sharecore.net/2014/07/05/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6/"/>
    <id>http://sharecore.net/2014/07/05/可扩展架构设计的三个维度/</id>
    <published>2014-07-04T16:00:01.000Z</published>
    <updated>2015-03-16T16:29:30.000Z</updated>
    
    <content type="html">&lt;p&gt;业界对于可扩展的系统架构设计有一个朴素的理念,就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过加机器就可以解决容量和可用性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而言，容量和性能问题当然是首当其冲的。但是随着时间的向前，系统规模的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时并未充分考虑到这些问题，导致系统的重构成为常态，从而影响业务交付能力，还浪费人力财力！&lt;/p&gt;
&lt;p&gt;对此，《可扩展的艺术》一书提出了一个更加系统的可扩展模型——&lt;strong&gt;AKF可扩展立方&lt;/strong&gt;（Scalability Cube）。这个立方体中沿着三个坐标轴设置分别为：X、Y、Z。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X轴扩展 —— 关注水平的数据和服务克隆，也就是前文提到的“加机器解决问题”
Y轴扩展 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分 
Z轴扩展 —— 关注服务和数据的优先级划分，如分地域划分
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个扩展模型，用下图来表示，其中原点代表完全无扩展的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/akf.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.X轴扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;X轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。我们以生产汽车的工厂来举例：假设一个车间能完整的生产一辆汽车，为了短时间内生产更多的汽车，我们可以建设更多的车间，任何新增车间除了工作的效率可能不同之外，都是一个新的复制品，也能提供与原来车间相同的工作，生产出完整的汽车。给复制品分配工作就是一个X轴扩展的一个完美示例，说明了X轴扩展的思路，即把工作无偏向的分配给复制品，每个复制品在不考虑生产效率的情况下，谁来做这项工作是无偏向的,&lt;strong&gt;各个复制品之间不共享任何内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在工程技术上来讲，X轴扩展主要有以下两种技术方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;故名思议，负载均衡就是将用户的访问请求通过负载均衡器，均衡分配到由各个“复制品”组成的集群中去。当某个复制品出现故障，也能轻易地将相应“工作”转移给其它的复制品来“代为完成”。这中间涉及到的工程技术点包括了反向代理，DNS轮询，哈希负载均衡算法（一致性哈希），动态节点负载均衡（如按CPU，I/O）等。它的难点在于要求集群中的“复制品”是不共享任何内容，也就是我们常说的&lt;strong&gt;无状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.数据复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据复制是指在数据存储层进行绝对平等地数据迁移，用于解决存储层I/O瓶颈以及可用性上的问题。由于存在多个复制品存储，为了使得每个复制品提供无差异的数据服务，我们需要在复制品之间同步或异步地复制数据。数据复制的方式包括了主从同步（常见的读/写分离），双主同步等。因为数据存储天生就是有状态的，数据复制的难点在于&lt;strong&gt;一致性&lt;/strong&gt;的保证上，为了一致性的保证，从而也衍生了很多复杂的技术，比如Paxos选举算法等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.Y轴扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Y轴扩展表示的是根据数据的类型或者交易执行的类型（或者两者都有）来划分工作职责。一般称为面向服务或面向资源的扩展。我们再以生产汽车的工厂来举例：如亨利.福特所做的一样，将汽车制造的工序按专业性分成不同车间和流水线，不再是一个车间负责完成100%的任务，制造一辆完整的汽车，而是让这每个车间都执行一些子任务，如安装发动机，喷漆，安装玻璃等等。这样的分工，益处是明显的，每个车间负责的&lt;strong&gt;任务更简单&lt;/strong&gt;，从而能更专业更高效的完成生产。&lt;/p&gt;
&lt;p&gt;与汽车工厂的分工类似，为了降低系统复杂度，Y轴扩展会将庞大的整体应用拆分为一组服务。每个服务实现一组相关的功能，如订单管理、客户管理等。在工程上常见的方案是&lt;strong&gt;服务化架构(SOA)&lt;/strong&gt;。比如对于一个电子商务平台，我们可以拆分成不同的服务，组成下面这样的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;但通过观察上图容易发现，当服务数量增多时，服务调用关系变得复杂。为系统添加一个新功能，要调用的服务数也变得不可控，由此引发了服务管理上的混乱。所以，一般情况下，需要采用服务注册的机制形成服务网关来进行服务治理。系统的架构将变成下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa1.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时，为了提升单个服务的可用性和容量，&lt;strong&gt;对每一个服务进行X轴扩展划分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/soa2.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.Z轴扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Z轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但又是完整的。继续以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种Z轴扩展。&lt;/p&gt;
&lt;p&gt;对于系统而言，Z轴扩展一般是为了满足差异性的需求或者是为了安全隔离而采取的扩展措施。比如为了提供VIP用户服务，可以将系统完整地复制一份出来，与普通用户所使用的系统完全隔离开来;再如，针对不同的地域用户，系统自动切换到对应地域的子系统，为用户提供服务，都可以认为是Z轴扩展。同时，在系统的灰度部署上，我们也通常使用Z轴扩展来完成。&lt;/p&gt;
&lt;p&gt;工程领域常见的Z轴扩展有以下两种方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.单元化架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分布式服务设计领域，一个单元（Cell）就是满足某个分区所有业务操作的自包含闭环。如上面我们说到的Y轴扩展的SOA架构，客户端对服务端节点的选择一般是随机的，但是，如果在此加上Z轴扩展，那服务节点的选择将不再是随机的了，而是每个单元自成一体。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/cell.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.数据分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了性能数据安全上的考虑，我们将一个完整的数据集按一定的维度划分出不同的子集。&lt;br&gt;一个分区（Shard），就是是整体数据集的一个子集。比如用尾号来划分用户，那同样尾号的那部分用户就可以认为是一个分区。数据分区为一般包括以下几种数据划分的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数据类型（如：业务类型）
数据范围（如：时间段，用户ID）
数据热度（如：用户活跃度，商品热度）
按读写分（如：商品描述，商品库存）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，数据分区也是有代价的，它将增加数据运维的难度，关联搜索的复杂度增加等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个在可扩展性上设计良好的系统，会充分考虑三个维度上的可扩展性。X轴上扩展处理的是平台或系统执行的交易量或工作量增长，虽然X轴扩展能够很好处理交易量的增长，但当系统复杂度的大幅度增加，或用户数量增加以及差异化服务需求出现，X轴扩展就难以应付了，如是我们可以通过Y轴扩展来处理系统复杂度增长的问题以及Z轴扩展来处理差异性化需求的问题。而当采用的扩展坐标轴不止一条时，那么&lt;strong&gt;X轴扩展总是其它扩展方法的次级划分&lt;/strong&gt;。同时，这三个维度扩展性，使得系统性能上改善有了更多的方向，对于系统性能优化，也是至关重要。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;业界对于可扩展的系统架构设计有一个朴素的理念,就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过加机器就可以解决容量和可用性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而言，容量和性能问题当然是首当其冲的
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://sharecore.net/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>值得借鉴的Google测试经验</title>
    <link href="http://sharecore.net/2014/06/29/%E5%80%BC%E5%BE%97%E5%80%9F%E9%89%B4%E7%9A%84Google%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>http://sharecore.net/2014/06/29/值得借鉴的Google测试经验/</id>
    <published>2014-06-28T16:01:03.000Z</published>
    <updated>2015-03-16T16:29:52.000Z</updated>
    
    <content type="html">&lt;p&gt;近来读了《Google软件测试之道》一书，以下是我从书里得来的两点经验：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.紧密结合开发过程与测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试之难，保证产品开发质量之难，每个公司每个团队，都会碰到各自的的问题和困难。但最为常见的抱怨（尤其是在互联网行业）是：&lt;strong&gt;开发人员不重视测试，测试人员人手不足，开发迭代又快，测不过来&lt;/strong&gt;。不少团队还喜欢争论开发测试比是1：1还是1：5或者5：1的问题,经常搬出微软这些传统软件巨头的开发测试比是多少多少来为自己辩护。其实，靠堆积人海战术的测试，是不适合在线型的快速的产品交付模式的。Google在这条路上就是另辟新径。&lt;/p&gt;
&lt;p&gt;Google的“新径”说到底其实也很简单，就是将开发过程和测试混合在一起，密不可分，他们认为测试是开发过程中必不可少的部分，当开发过程和测试一起携手联姻时，即是质量达成之时。 &lt;/p&gt;
&lt;p&gt;Google的测试主管Patrick说道：&lt;br&gt;&lt;strong&gt;&lt;em&gt;一个团队能编写出高质量的产品的唯一途径是全体人员共同对质量负责，包括产品经理，开发人员，测试人员等所有人。达到此目的最好方式是使测试人员有能力将测试变成代码库的一个实际功能，而测试功能的地位和应该与真是客户看到的任何其它功能同等重要。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google将工程师团队分成以下三种角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 软件开发工程师(SWE，software engineer)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SWE就是传统上的开发角色，他们的职责就是实现用户使用功能的代码。但是除此之外，&lt;strong&gt;SWE还需要编写测试代码，包括进行测试驱动的设计，单元测试，参与构建各种大小规模的测试等&lt;/strong&gt;。简单来说，SWE所有时间都是花在了代码编写上，包括功能代码以及对这些功能代码进行测试用的测试代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 软件测试开发工程师(SET,software engineer in test)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SET应该是Google能促进开发过程与测试紧密合起来的最关键角色&lt;/strong&gt;。SET的工作重心在于提供可测试性和通用性测试的基础框架上。传统的测试由于这一角色的缺乏，导致产品的可测试性难以保证，最后沦为开发人员由于编写测试代码困难，不愿意去写测试代码，而测试人员由于模块化测试困难，导致不能尽早介入到开发流程中去，而只能在产品交互后做停留在表面的集成测试。&lt;/p&gt;
&lt;p&gt;而SET这一角色的存在，很好的解决了这一个问题。SET会提供各种mock/fake框架，SWE在编写代码时，可以利用这些框架与外部依赖解耦，使得产品的单元测试和测试的自动执行变得相当容易。同时，集成测试也可以更早地进行，提高了测试人员的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.测试工程师(TE,test engineer)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TE更多地代表的是用户利益，他们需要把用户放在第一位来思考&lt;/strong&gt;。 TE需要组织整体的质量实践，分析和解释测试执行结果，驱动测试执行，构建端到端的自动化测试。他们早期会通过关注bug数，以&lt;strong&gt;确认开发人员在测试方面是做得到位&lt;/strong&gt;。当bug数减少后，他们在以用户使用的场景，来进行&lt;strong&gt;探索性的测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以上三个角色的紧密配合，完成了开发过程与测试的“联姻”。而这个负责“牵红线的月老”，我想就是SET这个角色。SET是产品可测试性的保证。同时，可测试性不只是将开发过程和测试紧密结合的基础，同时还是检验代码质量和架构是否优良的最好工具。我一直信奉下面这个公式：&lt;strong&gt;&lt;em&gt;可测试性=低耦合=优秀的代码=良好的架构&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.版本发布的“爬，走，跑”模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉google产品的，应该经常能看到google许多发布的版本后面都带着beta的标签，如我现在是用的chrome版本就是“33.0.1750.29 beta”。许多产品在线运营了多年，beta的标签也没有去掉，这个标签是在警示用户，产品仍处于改良之中。对于最终用户，只有产品达到99.99%的可用性，才会将beta的标签去掉。&lt;/p&gt;
&lt;p&gt;一般一个产品在发布给用户之前，一般要经历金丝雀版本，开发版本，测试版本，beta或正式发布版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;金丝雀版本&lt;/strong&gt;:即每日构建版本，用来排除一些明显问题的版本。这是一个极不稳定的版本，可能随时崩溃。一般只有产品的工程师（开发或测试人员）才会安装使用金丝雀版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发版本&lt;/strong&gt;：这个是开发人员日常使用的版本，一般是每周发布一个。该版本具有一定的功能并通过了一系列的测试。所有这个产品下的工程师都被要求去安装这个版本，并在日常工作中真正使用它。这其实体现“Eating your own dog food”的软件开发“黄金法则”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试版本&lt;/strong&gt;：这是一个通过了持续测试的版本,一般是一个月里最佳版本。一般可以被挑选为内部尝鲜，当做整个公司的“dog food”。如果该版本能持续表现良好，可作为beta测试的候选版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;beta或发布版本&lt;/strong&gt;：这个版本由非常稳定的测试版本演变而来，并经历了内部使用和通过所有质量考核的一个版本，也是对外发布的第一个版本。&lt;/p&gt;
&lt;p&gt;这种“爬，走，跑”的模式，能给产品提供一个测试验证的良好机会，并尽快得到使用过程中的反馈。&lt;/p&gt;
&lt;p&gt;以上两点，就是《Google软件测试之道》一书能带来的两点经验，书的其它大部分内容是许多Google内部人士的访谈，我认为这部分都“太Google”了，价值不是太大，也是此书的问题所在。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近来读了《Google软件测试之道》一书，以下是我从书里得来的两点经验：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.紧密结合开发过程与测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试之难，保证产品开发质量之难，每个公司每个团队，都会碰到各自的的问题和困难。但最为常见的抱怨（尤其是在互联网
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="测试" scheme="http://sharecore.net/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>过载保护算法浅析</title>
    <link href="http://sharecore.net/2014/06/21/%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://sharecore.net/2014/06/21/过载保护算法浅析/</id>
    <published>2014-06-20T16:01:40.000Z</published>
    <updated>2015-03-16T16:30:03.000Z</updated>
    
    <content type="html">&lt;p&gt;何为&lt;strong&gt;过载保护&lt;/strong&gt;？所谓“过载”，即需求超过了负载能力;而“保护”则是指当“过载”发生了，采取必要的措施保护自己不受“伤害”。在计算机领域，尤其是分布式系统领域，“过载保护”是一个重要的概念。一个不具备“过载保护”功能的系统，是非常危险和脆弱的，很可能由于瞬间的压力激增，引起“&lt;strong&gt;雪崩效应&lt;/strong&gt;”，导致系统的各个部分都同时崩溃，停止服务。这就好像在没有保险丝的保护下，电压突然变高，导致所有的电器都会被损坏一样，“过载保护”功能是系统的“保险丝”。&lt;/p&gt;
&lt;p&gt;去年开始，写了一个RPC服务框架，用以承接各个业务系统在其上进行各类业务服务接口的开发与部署，供远端调用。之于此类的框架，“过载保护”就是一个必须具备的功能特性，用以保护底层提供服务的业务系统不受“恶意”调用或突发性调用的破坏。而在整个实现整个功能的过程中，我发现实现“过载保护”算法是一个很有趣也比较有挑战的活。今天就稍微介绍一下这方面的算法吧。&lt;/p&gt;
&lt;p&gt;可能跟大多数人一样，拿到这个算法需求很容易想到一个简单而又有点粗暴的算法：设置一个单位时间（如10s）内的最大访问量，并维护一个单位时间里的计数器，当访问请求到达时，先判断单位控制时间是否已经超时，如果已经超时，重置计数器为0;否则，将计数器加1,并判断计数器的值是否超过最大访问量设置，如超过，则拒绝访问。&lt;/p&gt;
&lt;p&gt;具体的伪代码如下：（当然，具体的代码实现还有考虑并发的情况）&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeStamp=getNowTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reqCount=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxReqCount=&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//时间周期内最大请求数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; effectiveDuration=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//时间控制周期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;bool &lt;span class=&quot;title&quot;&gt;grant&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; now=getNowTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (now &amp;lt;timeStamp+effectiveDuration)&amp;#123;&lt;span class=&quot;comment&quot;&gt;//在时间控制范围内&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reqCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reqCount&amp;gt;maxReqCount;&lt;span class=&quot;comment&quot;&gt;//当前时间范围内超过最大请求控制数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timeStamp=now;&lt;span class=&quot;comment&quot;&gt;//超时后重置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reqCount=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该算法实现确实是实现了“单位时间里最大访问量控制”这一需求，但是，仔细研究下，发现它在两个单位时间的临界值上的处理是有缺陷的。如：设需要控制的最大请求数为1w, 在第一个单位时间的最后一秒里达到的请求数为1w,接下来第二个单位时间内的第一秒里达到请求数也是1w,由于超时重置发生在两个单位时间之间，所以这2w个请求都将通过控制，也就是说在2s里处理2w个请求，与我们设置的10s里1w个请求的需求相违背。&lt;/p&gt;
&lt;p&gt;换句话说，这个算法，对请求的控制不够平滑。那是不是还有更平滑的算法呢？有，&lt;strong&gt;漏桶算法（Leaky Bucket）&lt;/strong&gt;就是其一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Leaky_bucket.JPG&quot;&gt;&lt;/p&gt;
&lt;p&gt;（图来自wikipedia）&lt;/p&gt;
&lt;p&gt;如上图所示，我们假设系统是一个漏桶，当请求到达时，就是往漏桶里“加水”，而当请求被处理掉，就是水从漏桶的底部漏出。水漏出的速度是固定的，当“加水”太快，桶就会溢出，也就是“拒绝请求”。从而使得桶里的水的体积不可能超出桶的容量。&lt;/p&gt;
&lt;p&gt;上面的分析可以看出，该算法存在三个变量：桶的容量capacity，水漏出的速度rate，以及当前的水量water。&lt;/p&gt;
&lt;p&gt;算法伪代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeStamp=getNowTime();        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; capacity;        &lt;span class=&quot;comment&quot;&gt;// 桶的容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rate ;          &lt;span class=&quot;comment&quot;&gt;//水漏出的速度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; water;          &lt;span class=&quot;comment&quot;&gt;//当前水量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;bool &lt;span class=&quot;title&quot;&gt;grant&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//先执行漏水，因为rate是固定的，所以可以认为“时间间隔*rate”即为漏出的水量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  now = getNowTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  water = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, water- (now - timeStamp)*rate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  timeStamp = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (water &amp;lt; capacity) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 水还未满，加水&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    water ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//水满，拒绝加水&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上算法，我们可以通过调整capacity的值，来控制系统处理的最大请求数。而上文我们提到的时间边界处理的不够平滑问题，也可以很好的解决了，因为在每次进桶前都将执行“漏水”的操作，时间的切片不再是一个固定的值。&lt;/p&gt;
&lt;p&gt;如果你现在正在维基百科上查看“漏桶算法”的篇章，你会发现有一个与“漏桶算法”相关联的算法叫&lt;strong&gt;令牌桶(Tocken Bucket)&lt;/strong&gt;算法。令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。&lt;/p&gt;
&lt;p&gt;令牌桶算法伪代码如下，跟漏桶算法很相似：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeStamp=getNowTime();        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; capacity;              &lt;span class=&quot;comment&quot;&gt;// 桶的容量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rate ;              &lt;span class=&quot;comment&quot;&gt;//令牌放入速度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tokens;            &lt;span class=&quot;comment&quot;&gt;//当前水量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;bool &lt;span class=&quot;title&quot;&gt;grant&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//先执行添加令牌的操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  now = getNowTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tokens = max(capacity, tokens+ (now - timeStamp)*rate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  timeStamp = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//令牌已用完，拒绝访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(tokens&amp;lt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//还有令牌，领取令牌&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tokens--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retun &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上是关于漏桶算法和令牌桶算法的基本介绍，你趋向于用哪个呢？我现在用的是“漏桶”，没有什么原因，因为我首先看到的它，然后才看到“令牌桶”。但当然，实现这两个算法后，离真正的过载保护还有许多工程上的问题需要解决，比如当系统是多个节点组成的集群来提供服务时，我们需要统一的存储（一般用Redis之类的内存级存储较为合适）来维护当前桶的状态。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;何为&lt;strong&gt;过载保护&lt;/strong&gt;？所谓“过载”，即需求超过了负载能力;而“保护”则是指当“过载”发生了，采取必要的措施保护自己不受“伤害”。在计算机领域，尤其是分布式系统领域，“过载保护”是一个重要的概念。一个不具备“过载保护”功能的系统，是非常危险和脆弱的，
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://sharecore.net/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="算法" scheme="http://sharecore.net/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>程序员持续学习之道</title>
    <link href="http://sharecore.net/2014/06/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    <id>http://sharecore.net/2014/06/15/程序员持续学习之道/</id>
    <published>2014-06-14T16:02:25.000Z</published>
    <updated>2015-03-16T16:30:14.000Z</updated>
    
    <content type="html">&lt;p&gt;我其实是一个悲观主义者，从开始成为一名程序员的那一天开始，我就对自己的职业充满着担忧。早期，我担忧的是我刚进入这一行，落后身边从事这一行多年的人太多，跟他们比，我一开始就处于“不公平“的起跑线上；二是当我稍微深入这行后，发现技术的道路充满了歧路和死胡同，稍不留神，就将落入再也跟不上技术进步的节奏，身边也充斥着类似的示例。&lt;/p&gt;
&lt;p&gt;好在在这条路上，我找到了一个克服担忧的良方：学习，坚持不懈的学习！&lt;/p&gt;
&lt;p&gt;人类最大的恐惧莫过于对未知的恐惧，而学习，是克服未知的一个最有效途径。那作为一个程序员，该如何才能做到坚持不懈的学习呢？我想主要有以下几点：&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;1. 不抗拒变化，跟踪变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说的变化，更多指的是技术的变化。新技术永远层出不穷，如果你抗拒变化，或惧怕变化，在心里优势上就落后了一大截。很多程序员的技术道路越走越窄，当一门新技术来临时，他们从不去了解或研究，他们要么认为这是”换汤不换药“的”技术幌子“，不值得去研究，要么等着别人去研究，自己被动的接受别人的结论与成果。诚然，等待别人的研究结果也可行，但是，当身边没有人去研究呢？当研究的人不愿意提供给你他的研究结果呢？当别人的结论和结果是错误的呢？&lt;/p&gt;
&lt;p&gt;当然，业界的新技术层出不穷，要去跟踪每一项新技术的变化也是不可能的，我的建议是尽量掌握基础的技术，越是基础的技术越是恒定。如计算机的体系架构，TCP，HTTP，各类编程范式，OOP，MVC架构等，都是好多年来没有发生过变化的技术了。许多新技术也是建立在他们上面，当你了解了这些基础的技术，建立在他们之上的新技术也就能很快掌握了，并能迅速而准确地对这些新技术作出“价值判断”。&lt;/p&gt;
&lt;p&gt;技术的变化，其实也并不全是指业界的新技术来临，更多指的是，超出自己当前技术能力外，&lt;strong&gt;主动研究和选择的“新技术” ，主动丢弃老的套路和技术，不固步自封&lt;/strong&gt;。见过很多的程序员，他们写了很多年的代码了，技术能力还停留在数据库层写一个Sql(存储过程)+前端调用上。为什么如此呢？因为自开始写代码起，这样简单粗暴的方式就可以解决他们面对的问题了。所以，当碰到新的问题，他们就继续沿用着这种方式，而从不去看看业界是不是有更合适的方案来解决。长此以往，他们的技术能力也就不会有任何的变化，工作十年，只是将第一年所学的技术重复十年而已。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2. 书宜杂读，业宜精钻&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建筑学家梁思成赴美留学，其父梁启超告诫说：你该挤出一部分时间学些常识性东西，特别是文学或人文科学，稍稍多用点工夫就能有大的收获。我深怕你因所学太专一，把多彩的生活弄得平平淡淡，生活过于单调，则生厌倦心理，厌倦一生即成苦恼之事……书宜杂读，业宜精钻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习本身应该是一件很快乐的事情，但如果只是一味地沉浸于专业学习之中，难免会将本来快乐的事情弄成平淡和单调，更可怕的是，由此产生厌倦心理，放弃学习。&lt;/p&gt;
&lt;p&gt;所以，可以尽量跟随自己的兴趣，去更广泛地读书。历史，文学，心理学，哲学等等各方面的书都可以尝试去读，它们不仅丰富你的知识，更能让你在阅读中受到感动、教育和启迪。&lt;strong&gt;书读的更多更广泛，知道的事也就多，思路更加开阔，解决问题的能力也就能高于常人，从而反过来帮助到你专业能力的提升。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;3. 投资团队，积极打造学习型团队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代社会，难免的一点就是个人必须置身于群体之中，程序员更是如此。从群体心理学的角度来看，在群体里，个人的才智被削弱，异质性被同质性所吞没。由此，&lt;strong&gt;如果一个团队不爱学习，那么，其中的成员也很难坚持学习&lt;/strong&gt;（个性和意志力特别强的人除外）。&lt;/p&gt;
&lt;p&gt;如果你爱学习，请想办法让你的团队也变得爱学习，这样，你对学习的坚持将变得更加容易。或许你认为建立学习氛围，是团队领导的事情，跟自己无关。领导当然可以来做也需要来做这样的事情，但要明白的一点，学习这事，如果变成从上向下，就难免“政治化”了，容易失去它本身的意义。而从下往上，更能建立轻松和谐的学习环境。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我其实是一个悲观主义者，从开始成为一名程序员的那一天开始，我就对自己的职业充满着担忧。早期，我担忧的是我刚进入这一行，落后身边从事这一行多年的人太多，跟他们比，我一开始就处于“不公平“的起跑线上；二是当我稍微深入这行后，发现技术的道路充满了歧路和死胡同，稍不留神，就将落入再
    
    </summary>
    
    
      <category term="学习" scheme="http://sharecore.net/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="常识" scheme="http://sharecore.net/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>粗略估算</title>
    <link href="http://sharecore.net/2014/06/08/%E7%B2%97%E7%95%A5%E4%BC%B0%E7%AE%97/"/>
    <id>http://sharecore.net/2014/06/08/粗略估算/</id>
    <published>2014-06-07T16:03:08.000Z</published>
    <updated>2015-03-16T16:30:25.000Z</updated>
    
    <content type="html">&lt;p&gt;今天我们以两道可能看起来有点“惨无人道”的题目开始&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;&lt;em&gt;1.一个长方体的卡车车厢能装下多少个高尔夫球？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;&lt;em&gt;2.密西西比河一天流出多少水？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一个题目据说是Google的“产品经理”职位面试题，大家可能已经在网络上有过了解;第二个问题来自《编程珠玑》一书。&lt;/p&gt;
&lt;p&gt;很容易看出，这两道题的难点在于很难得出一个准确的答案。如果大家将思路放在寻找一个具体而精确的答案上的话，就落入了陷阱，因为这两道题要讨论的是另外一个主题：&lt;strong&gt;粗略估算&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓粗略估算，是指在已知的有限信息下，对一些似乎是算不出来的量，作出合理的&lt;strong&gt;猜测&lt;/strong&gt;，通常用来作量纲分析。&lt;/p&gt;
&lt;p&gt;我们先看看这两道题的答案是什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设卡车车厢的容积（长×宽×高）=10m×2m×3m=60m³，一个高尔夫球的半径大约为10cm，根据球体体积=4/3πr³，高尔夫球体积约为0.004m³（其它小数位，我们可以忽略，因为球体之间会存在缝隙），如是可得：卡车车厢可容纳60/0.004=15000个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;猜测出河的出口大约1英里宽和20英尺深，猜测河水的流速是每小时5英里，换算成天就是120英里。由体积公式可得：1英里×1/250英里×120英里/天 = 0.5英里³/天。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在以上的答案中，体现了粗略估算的两个关键点：&lt;strong&gt;公式与猜测&lt;/strong&gt;。公式，是进行估算的整体模型，而猜测，是对缺失信息的补充。这两者，一方面取决于我们的知识，比如知识告可以告诉我们，球体体积的计算公式是4/3πr³，另一方面取决我们的经验。但归根结底，经验更为重要。因为估算要应对的情况更多是信息的缺乏，所以需要更多的利用我们的经验（包括生活经验，工程经验等）来进行猜测，以补充缺失的信息，在平时更善于捕获和总结经验所得的人，或在某方面有更多历练的人，在某方面的估算上也就更有优势，比如一个有过性能调优经验的程序员，他在程序的性能估算上就会更加擅长。&lt;/p&gt;
&lt;p&gt;在科学界还有另外一个更“学术”的名称叫&lt;strong&gt;费米估算&lt;/strong&gt;（或费米问题），它的命名来自物理学家&lt;em&gt;恩里科·费米&lt;/em&gt;，费米以他通过非常少量或不精确的数据来得到比较好的估计的能力而被广泛熟知。一个例子就是他在主要领导的曼哈顿计划（美/英/加三国联合的原子弹制造计划）中估算核爆炸的”爆炸力相当量“。1945年7月16日晚，原子弹在内华达州的沙漠引爆成功时，费米在原子弹试爆现场附近，突然跃起向空中撒了一把碎纸片，爆炸后气浪将纸片急速地卷走，他紧追纸片跑了几步，并根据纸片飞出的距离估算了核爆炸的”爆炸力相当量“，费米计算出的爆炸威力相当于一万吨TNT炸药，非常接近现在所接受的二万吨的数值，之间的误差少于一个数量级。&lt;/p&gt;
&lt;p&gt;费米还善于提出各种估算的问题，比如他提出的一个经典的费米问题：&lt;strong&gt;在芝加哥有多少钢琴调琴师？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题的一个经典答案是建立在一系列的猜测上的：&lt;/p&gt;
&lt;p&gt;首先，建立我们估算的模型：&lt;strong&gt;需求=供给&lt;/strong&gt;。即需要被调整的钢琴数等于钢琴师可以调整的钢琴数。我们需要估算出一年中芝加哥有多少钢琴需要被调整以及一个钢琴师一年大概能调多少台钢琴，由此，我们作出以下一系列假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;芝加哥的居民数大约为5,000,000人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平均一个家庭有2个人，在20个家庭中有一个家庭需要定期调钢琴&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定期调琴的周期为1年，每个调琴师大约要2小时来完成一次调琴&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个调琴师每天工作8小时，一周5天，一年50周（为便于快速计算，将尾数去掉也是进行粗略估算的一个基本技巧）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这些假设我们可以计算出芝加哥每年需要调整的钢琴数量为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(5,000,000 人) / (2 人/家) × (1 架钢琴/20 家) × (1 架钢琴调整/1年) = &lt;strong&gt;125,000架&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;类似地计算出平均每个调琴师：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(50 周/年)×(5 天/周)×(8 小时/天)/(1 架钢琴/2小时) = &lt;strong&gt;1000 架钢琴每年/1调琴师&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进一步计算即得出答案：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;125000架钢琴 /( 1000架钢琴每年/1调琴师) = &lt;strong&gt;125 个调琴师&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最后，我们在附上两个可用于粗略估算的小经验法则，以便大家更好的进行类似的估算：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“72法则”&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“72法则”主要用于指数级增长情况的估算&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;比如以r%的年利率投资一笔钱y年，如果r*y=72，那么你的投资差不多会翻倍。具体来看：以6%投资1000美元12年，可得到2012美元，以年利率8%投资1000美元9年，可得到1999美元。&lt;/p&gt;
&lt;p&gt;“72法则”对程序员估计一个时间复杂度是指数级的程序性能来说也非常有用，当n每增加1,运行时间就是增加12%时，那由“72法则”可得当n每增加6,运行时间就加倍了，或者n每增加60,运行时间增加为原来的1000倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Little定律&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于一个有输入和输出的系统，&lt;em&gt;*系统中物体的平均数量等于物体离开系统的平均速率和每个物体在系统中停留的平均时间的乘积&lt;/em&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;比如假设酒窖里有150箱酒，每年喝掉25箱并存入25箱，那么每箱酒的保存时间是多长呢？Little定律告诉我们：用150箱/25箱/年=6年&lt;/p&gt;
&lt;p&gt;再如：某个酒吧可以容纳约60人，每个人在里面逗留的时间大约是3小时，那进入该酒吧的速率大概就是每小时20人。也就意味着当你排队进入酒吧时，前面有20人排队，那你还需要等待大概一小时才可以进入酒吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们以两道可能看起来有点“惨无人道”的题目开始&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;&lt;em&gt;1.一个长方体的卡车车厢能装下多少个高尔夫球？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;&lt;em&gt;2.密西西比河一天流出多少水？&lt;/em&gt;&lt;/strong&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://sharecore.net/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://sharecore.net/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
